{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebTool(Alpha)","text":"<p>WebTool is Well-Architected FastAPI/Starlette library for authentication, throttling, caching, logging, and utilities.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install webtool\n</code></pre> <pre><code>poetry add webtool\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#authentication","title":"Authentication","text":"<p>JWT token management system with Redis-backed refresh tokens.</p> <pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache_client = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache_client)\n\n\nasync def get_token():\n    access, refresh = jwt_service.create_token({\"sub\": 123, \"scope\": [\"write\"]})\n    return access, refresh\n</code></pre>"},{"location":"#throttling","title":"Throttling","text":"<p>Rate limiting system for FastAPI/Starlette applications.</p> <pre><code>from fastapi import FastAPI\nfrom starlette.middleware import Middleware\nfrom webtool.auth import JWTService\nfrom webtool.cache import RedisCache\nfrom webtool.throttle import limiter, LimitMiddleware, JWTBackend\n\ncache = RedisCache(\"redis://127.0.0.1:6379/0\")\njwt_backend = JWTBackend(JWTService(cache, secret_key=\"test\"))\n\napp = FastAPI(\n    middleware=[\n        Middleware(\n            LimitMiddleware,\n            cache=cache,\n            auth_backend=jwt_backend,\n        ),\n    ],\n)\n\n\n@app.get(\"/api/resource\")\n@limiter(max_requests=50, interval=3600, scopes=[\"user\"])\n@limiter(max_requests=10, interval=3600, scopes=[\"anno\"])\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#msgpack-response","title":"MsgPack Response","text":"<p>MessagePack-based response.</p> <pre><code>from webtool.utils import MsgSpecJSONResponse\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    default_response_class=MsgSpecJSONResponse,\n)\n\n\n@app.get(\"/api/resource\")\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache-2.0 License.</p>"},{"location":"learn/cache/client/","title":"Cache - client","text":""},{"location":"learn/cache/client/#webtool.cache.client.DEFAULT_CAP","title":"DEFAULT_CAP  <code>module-attribute</code>","text":"<pre><code>DEFAULT_CAP = 0.512\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.DEFAULT_BASE","title":"DEFAULT_BASE  <code>module-attribute</code>","text":"<pre><code>DEFAULT_BASE = 0.008\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache","title":"BaseCache","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for Redis client implementations. Defines the interface for performing safe Redis operations.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>class BaseCache(ABC):\n    \"\"\"\n    Abstract base class for Redis client implementations.\n    Defines the interface for performing safe Redis operations.\n    \"\"\"\n\n    cache: Any\n    connection_pool = Any\n\n    @abstractmethod\n    async def lock(\n        self,\n        key: Union[bytes, str, memoryview],\n        ttl_ms: Union[int, timedelta, None] = 100,\n        blocking: bool = True,\n        blocking_timeout: float = DEFAULT_CAP,\n        blocking_sleep: float = DEFAULT_BASE,\n    ) -&gt; BaseLock:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def set(\n        self,\n        key: Union[bytes, str, memoryview],\n        value: Union[bytes, memoryview, str, int, float],\n        ex: Union[int, timedelta, None] = None,\n        exat: Union[int, datetime, None] = None,\n        nx: bool = False,\n    ) -&gt; Any:\n        \"\"\"\n        sets a key-value pair.\n\n        :param key: The key for the data to be set.\n        :param value: The value associated with the key.\n        :param ex: Expiration time for the key, in seconds or as a timedelta.\n        :param exat: Expiration time as an absolute timestamp.\n        :param nx: if set to True, set the value at key to value only if it does not exist.\n\n        :return: return of set.\n\n        :raises NotImplementedError: If the method is not implemented in a subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def get(\n        self,\n        key: Union[bytes, str, memoryview],\n    ) -&gt; Any:\n        \"\"\"\n        gets a key-value pair.\n\n        :param key: The key for the data to be set.\n        :return: return of get.\n\n        :raises NotImplementedError: If the method is not implemented in a subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(\n        self,\n        key: Union[bytes, str, memoryview],\n    ) -&gt; Any:\n        \"\"\"\n        deletes a key-value pair.\n\n        :param key: The key for the data to be set.\n        :return: None\n\n        :raises NotImplementedError: If the method is not implemented in a subclass.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def aclose(self) -&gt; None:\n        \"\"\"\n        Closes the Redis client connection and connection pool.\n\n        :raises NotImplementedError: If the method is not implemented in a subclass.\n        \"\"\"\n\n        raise NotImplementedError\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.connection_pool","title":"connection_pool  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>connection_pool = Any\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.lock","title":"lock  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>lock(\n    key,\n    ttl_ms=100,\n    blocking=True,\n    blocking_timeout=DEFAULT_CAP,\n    blocking_sleep=DEFAULT_BASE,\n)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>@abstractmethod\nasync def lock(\n    self,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None] = 100,\n    blocking: bool = True,\n    blocking_timeout: float = DEFAULT_CAP,\n    blocking_sleep: float = DEFAULT_BASE,\n) -&gt; BaseLock:\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.set","title":"set  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>set(key, value, ex=None, exat=None, nx=False)\n</code></pre> <p>sets a key-value pair.</p> <p>:param key: The key for the data to be set. :param value: The value associated with the key. :param ex: Expiration time for the key, in seconds or as a timedelta. :param exat: Expiration time as an absolute timestamp. :param nx: if set to True, set the value at key to value only if it does not exist.</p> <p>:return: return of set.</p> <p>:raises NotImplementedError: If the method is not implemented in a subclass.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>@abstractmethod\nasync def set(\n    self,\n    key: Union[bytes, str, memoryview],\n    value: Union[bytes, memoryview, str, int, float],\n    ex: Union[int, timedelta, None] = None,\n    exat: Union[int, datetime, None] = None,\n    nx: bool = False,\n) -&gt; Any:\n    \"\"\"\n    sets a key-value pair.\n\n    :param key: The key for the data to be set.\n    :param value: The value associated with the key.\n    :param ex: Expiration time for the key, in seconds or as a timedelta.\n    :param exat: Expiration time as an absolute timestamp.\n    :param nx: if set to True, set the value at key to value only if it does not exist.\n\n    :return: return of set.\n\n    :raises NotImplementedError: If the method is not implemented in a subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.get","title":"get  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>gets a key-value pair.</p> <p>:param key: The key for the data to be set. :return: return of get.</p> <p>:raises NotImplementedError: If the method is not implemented in a subclass.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>@abstractmethod\nasync def get(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    \"\"\"\n    gets a key-value pair.\n\n    :param key: The key for the data to be set.\n    :return: return of get.\n\n    :raises NotImplementedError: If the method is not implemented in a subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.delete","title":"delete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>deletes a key-value pair.</p> <p>:param key: The key for the data to be set. :return: None</p> <p>:raises NotImplementedError: If the method is not implemented in a subclass.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>@abstractmethod\nasync def delete(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    \"\"\"\n    deletes a key-value pair.\n\n    :param key: The key for the data to be set.\n    :return: None\n\n    :raises NotImplementedError: If the method is not implemented in a subclass.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.BaseCache.aclose","title":"aclose  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Closes the Redis client connection and connection pool.</p> <p>:raises NotImplementedError: If the method is not implemented in a subclass.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>@abstractmethod\nasync def aclose(self) -&gt; None:\n    \"\"\"\n    Closes the Redis client connection and connection pool.\n\n    :raises NotImplementedError: If the method is not implemented in a subclass.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache","title":"InMemoryCache","text":"<p>               Bases: <code>BaseCache</code></p> <p>Implementation of a InMemory client. DO NOT USE IN PRODUCTION</p> Source code in <code>webtool/cache/client.py</code> <pre><code>class InMemoryCache(BaseCache):\n    \"\"\"\n    Implementation of a InMemory client.\n    DO NOT USE IN PRODUCTION\n    \"\"\"\n\n    def __init__(self):\n        self.cache: dict = {}\n        self.connection_pool = None\n\n    async def _expire(self) -&gt; None:\n        now = asyncio.get_event_loop().time()\n        self.cache = {k: v for k, v in self.cache.items() if v[1] &gt; now}\n\n    def lock(\n        self,\n        key: Union[bytes, str, memoryview],\n        ttl_ms: Union[int, timedelta, None] = 100,\n        blocking: bool = True,\n        blocking_timeout: float = DEFAULT_CAP,\n        blocking_sleep: float = DEFAULT_BASE,\n    ) -&gt; BaseLock:\n        return AsyncInMemoryLock(self, key, ttl_ms, blocking, blocking_timeout, blocking_sleep)\n\n    async def set(\n        self,\n        key: Union[bytes, str, memoryview],\n        value: Union[bytes, memoryview, str, int, float],\n        ex: Union[int, timedelta, None] = None,\n        exat: Union[int, datetime, None] = None,\n        nx: bool = False,\n    ) -&gt; Any:\n        await self._expire()\n        if nx and self.cache.get(key):\n            return None\n\n        if ex:\n            now = asyncio.get_running_loop().time()\n            if isinstance(ex, (float, int)):\n                exp = now + ex\n            else:\n                exp = now + ex.total_seconds()\n        else:\n            if isinstance(exat, int):\n                exp = exat\n            elif isinstance(exat, datetime):\n                exp = exat.timestamp()\n            else:\n                exp = float(\"inf\")\n\n        self.cache[key] = (value, exp)\n        return self.cache[key]\n\n    async def get(\n        self,\n        key: Union[bytes, str, memoryview],\n    ) -&gt; Any:\n        await self._expire()\n\n        val = self.cache.get(key)\n        if val:\n            return val[0]\n        return None\n\n    async def delete(\n        self,\n        key: Union[bytes, str, memoryview],\n    ) -&gt; Any:\n        await self._expire()\n\n        return self.cache.pop(key)\n\n    async def aclose(self) -&gt; None:\n        self.cache.clear()\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache = {}\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.connection_pool","title":"connection_pool  <code>instance-attribute</code>","text":"<pre><code>connection_pool = None\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.lock","title":"lock","text":"<pre><code>lock(\n    key,\n    ttl_ms=100,\n    blocking=True,\n    blocking_timeout=DEFAULT_CAP,\n    blocking_sleep=DEFAULT_BASE,\n)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>def lock(\n    self,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None] = 100,\n    blocking: bool = True,\n    blocking_timeout: float = DEFAULT_CAP,\n    blocking_sleep: float = DEFAULT_BASE,\n) -&gt; BaseLock:\n    return AsyncInMemoryLock(self, key, ttl_ms, blocking, blocking_timeout, blocking_sleep)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ex=None, exat=None, nx=False)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def set(\n    self,\n    key: Union[bytes, str, memoryview],\n    value: Union[bytes, memoryview, str, int, float],\n    ex: Union[int, timedelta, None] = None,\n    exat: Union[int, datetime, None] = None,\n    nx: bool = False,\n) -&gt; Any:\n    await self._expire()\n    if nx and self.cache.get(key):\n        return None\n\n    if ex:\n        now = asyncio.get_running_loop().time()\n        if isinstance(ex, (float, int)):\n            exp = now + ex\n        else:\n            exp = now + ex.total_seconds()\n    else:\n        if isinstance(exat, int):\n            exp = exat\n        elif isinstance(exat, datetime):\n            exp = exat.timestamp()\n        else:\n            exp = float(\"inf\")\n\n    self.cache[key] = (value, exp)\n    return self.cache[key]\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def get(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    await self._expire()\n\n    val = self.cache.get(key)\n    if val:\n        return val[0]\n    return None\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def delete(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    await self._expire()\n\n    return self.cache.pop(key)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.InMemoryCache.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    self.cache.clear()\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig","title":"RedisConfig  <code>dataclass</code>","text":"<p>Configuration settings for establishing a connection with a Redis server.</p> <p>:param username (Optional[str]): username :param password (Optional[str]): password :param health_check_interval (int): Interval in seconds for performing health checks. :param socket_timeout (float): Timeout in seconds for socket operations, including reads and writes. :param socket_connect_timeout (float): Timeout in seconds for establishing a new connection to Redis. :param socket_keepalive (bool): Whether to enable TCP keepalive for the connection. Default is True. :param retry (Optional[Retry]): Retry policy for handling transient failures. :param retry_on_error (Optional[list[type[Exception]]]): A list of exception types that should trigger a retry. :param retry_on_timeout (bool): Whether to retry operations when a timeout occurs. :param ssl (bool): Specifies if SSL should be used for the Redis connection. :param protocol (Optional[int]): Redis protocol version to be used. Default is RESP3.</p> <p>Methods:</p> Name Description <code>to_dict</code> <p>Converts the configuration fields to a dictionary.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>@dataclass(frozen=True)\nclass RedisConfig:\n    \"\"\"\n    Configuration settings for establishing a connection with a Redis server.\n\n    :param username (Optional[str]): username\n    :param password (Optional[str]): password\n    :param health_check_interval (int): Interval in seconds for performing health checks.\n    :param socket_timeout (float): Timeout in seconds for socket operations, including reads and writes.\n    :param socket_connect_timeout (float): Timeout in seconds for establishing a new connection to Redis.\n    :param socket_keepalive (bool): Whether to enable TCP keepalive for the connection. Default is True.\n    :param retry (Optional[Retry]): Retry policy for handling transient failures.\n    :param retry_on_error (Optional[list[type[Exception]]]): A list of exception types that should trigger a retry.\n    :param retry_on_timeout (bool): Whether to retry operations when a timeout occurs.\n    :param ssl (bool): Specifies if SSL should be used for the Redis connection.\n    :param protocol (Optional[int]): Redis protocol version to be used. Default is RESP3.\n\n    Methods:\n        to_dict() -&gt; dict[str, Any]: Converts the configuration fields to a dictionary.\n    \"\"\"\n\n    username: Optional[str] = None\n    password: Optional[str] = None\n    health_check_interval: int = 0\n    socket_timeout: float = 0.5\n    socket_connect_timeout: float = 2.0\n    socket_keepalive: bool = True\n    retry: Optional[Retry] = Retry(default_backoff(), retries=3)\n    retry_on_error: Optional[list[type[Exception]]] = field(\n        default_factory=lambda: [BusyLoadingError, ConnectionError, RedisError, OSError]\n    )\n    retry_on_timeout: bool = True\n    ssl: bool = False\n    max_connections: Optional[int] = None\n    protocol: Optional[int] = 3\n\n    def to_dict(self) -&gt; dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if v}\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.username","title":"username  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>username = None\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password = None\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.health_check_interval","title":"health_check_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>health_check_interval = 0\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.socket_timeout","title":"socket_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>socket_timeout = 0.5\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.socket_connect_timeout","title":"socket_connect_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>socket_connect_timeout = 2.0\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.socket_keepalive","title":"socket_keepalive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>socket_keepalive = True\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.retry","title":"retry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry = Retry(default_backoff(), retries=3)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.retry_on_error","title":"retry_on_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_on_error = field(\n    default_factory=lambda: [\n        BusyLoadingError,\n        ConnectionError,\n        RedisError,\n        OSError,\n    ]\n)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.retry_on_timeout","title":"retry_on_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_on_timeout = True\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.ssl","title":"ssl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ssl = False\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.max_connections","title":"max_connections  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_connections = None\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.protocol","title":"protocol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protocol = 3\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return {k: v for k, v in self.__dict__.items() if v}\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache","title":"RedisCache","text":"<p>               Bases: <code>BaseCache</code></p> <p>Implementation of a Redis client with failover capabilities.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>class RedisCache(BaseCache):\n    \"\"\"\n    Implementation of a Redis client with failover capabilities.\n    \"\"\"\n\n    def __init__(\n        self,\n        redis_url: str = None,\n        connection_pool: Optional[ConnectionPool] = None,\n        logger: logging.Logger = None,\n        config: RedisConfig | None = None,\n    ):\n        \"\"\"\n        Initializes the Redis client.\n\n        :param redis_url: Redis data source name for connection.\n        :param connection_pool: Optional, an existing connection pool to use.\n        \"\"\"\n\n        self.logger = logger or logging.getLogger(__name__)\n        self.config = config or RedisConfig()\n\n        if connection_pool:\n            self.connection_pool = connection_pool\n        elif redis_url:\n            kwargs = self.config.to_dict()\n            kwargs.update(\n                {\n                    \"retry\": deepcopy(self.config.retry),\n                }\n            )\n            self.connection_pool = ConnectionPool.from_url(redis_url, **kwargs)\n        else:\n            raise TypeError(\"RedisClient must be provided with either redis_dsn or connection_pool\")\n\n        self.cache: Redis = Redis.from_pool(self.connection_pool)\n\n    def lock(\n        self,\n        key: Union[bytes, str, memoryview],\n        ttl_ms: Union[int, timedelta, None] = 100,\n        blocking: bool = True,\n        blocking_timeout: float = DEFAULT_CAP,\n        blocking_sleep: float = DEFAULT_BASE,\n    ) -&gt; AsyncRedisLock:\n        return AsyncRedisLock(self, key, ttl_ms, blocking, blocking_timeout, blocking_sleep)\n\n    async def set(\n        self,\n        key: Union[bytes, str, memoryview],\n        value: Union[bytes, memoryview, str, int, float],\n        ex: Union[int, timedelta, None] = None,\n        exat: Union[int, datetime, None] = None,\n        nx: bool = False,\n    ) -&gt; Any:\n        return await self.cache.set(key, value, ex=ex, exat=exat, nx=nx)\n\n    async def get(\n        self,\n        key: Union[bytes, str, memoryview],\n    ) -&gt; Any:\n        return await self.cache.get(key)\n\n    async def delete(\n        self,\n        key: Union[bytes, str, memoryview],\n    ) -&gt; Any:\n        return await self.cache.delete(key)\n\n    async def aclose(self) -&gt; None:\n        self.logger.info(f\"Closing Redis client connection (id: {id(self)})\")\n\n        try:\n            await self.cache.aclose()\n        except AttributeError as e:\n            self.logger.warning(f\"Failed to close Redis connection: {e}\")\n\n        try:\n            await self.connection_pool.aclose()\n            await self.connection_pool.disconnect()\n        except AttributeError as e:\n            self.logger.warning(f\"Failed to close connection pool: {e}\")\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger or getLogger(__name__)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or RedisConfig()\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.connection_pool","title":"connection_pool  <code>instance-attribute</code>","text":"<pre><code>connection_pool = connection_pool\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache = from_pool(connection_pool)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.lock","title":"lock","text":"<pre><code>lock(\n    key,\n    ttl_ms=100,\n    blocking=True,\n    blocking_timeout=DEFAULT_CAP,\n    blocking_sleep=DEFAULT_BASE,\n)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>def lock(\n    self,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None] = 100,\n    blocking: bool = True,\n    blocking_timeout: float = DEFAULT_CAP,\n    blocking_sleep: float = DEFAULT_BASE,\n) -&gt; AsyncRedisLock:\n    return AsyncRedisLock(self, key, ttl_ms, blocking, blocking_timeout, blocking_sleep)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ex=None, exat=None, nx=False)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def set(\n    self,\n    key: Union[bytes, str, memoryview],\n    value: Union[bytes, memoryview, str, int, float],\n    ex: Union[int, timedelta, None] = None,\n    exat: Union[int, datetime, None] = None,\n    nx: bool = False,\n) -&gt; Any:\n    return await self.cache.set(key, value, ex=ex, exat=exat, nx=nx)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def get(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    return await self.cache.get(key)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def delete(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    return await self.cache.delete(key)\n</code></pre>"},{"location":"learn/cache/client/#webtool.cache.client.RedisCache.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    self.logger.info(f\"Closing Redis client connection (id: {id(self)})\")\n\n    try:\n        await self.cache.aclose()\n    except AttributeError as e:\n        self.logger.warning(f\"Failed to close Redis connection: {e}\")\n\n    try:\n        await self.connection_pool.aclose()\n        await self.connection_pool.disconnect()\n    except AttributeError as e:\n        self.logger.warning(f\"Failed to close connection pool: {e}\")\n</code></pre>"},{"location":"learn/jwt/manager/","title":"Auth - manager","text":"<p>This module provides functionality for handling JSON Web Tokens (JWT) for authentication and authorization. It defines the structure and methods required to encode and decode JWTs, as well as manage the claims associated with the tokens.</p>"},{"location":"learn/jwt/manager/#webtool.auth.manager.BaseJWTManager","title":"BaseJWTManager","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing JSON Web Tokens (JWT). This class defines the interface for encoding and decoding JWT (RFC7519).</p> Note <p>\ub300\ubd80\ubd84\uc758 \uacbd\uc6b0 \ud574\ub2f9 \ud074\ub798\uc2a4\uc758 \ud558\uc704 \uad6c\ud604\uccb4\ub97c \uc9c1\uc811 \uc0ac\uc6a9\ud560 \ud544\uc694\ub294 \uac70\uc758 \uc5c6\uc2b5\ub2c8\ub2e4.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>class BaseJWTManager(ABC):\n    \"\"\"\n    Abstract base class for managing JSON Web Tokens (JWT).\n    This class defines the interface for encoding and decoding JWT (RFC7519).\n\n    Note:\n        \ub300\ubd80\ubd84\uc758 \uacbd\uc6b0 \ud574\ub2f9 \ud074\ub798\uc2a4\uc758 \ud558\uc704 \uad6c\ud604\uccb4\ub97c \uc9c1\uc811 \uc0ac\uc6a9\ud560 \ud544\uc694\ub294 \uac70\uc758 \uc5c6\uc2b5\ub2c8\ub2e4.\n    \"\"\"\n\n    @abstractmethod\n    def encode(\n        self,\n        claims: dict,\n        secret_key: str,\n        algorithm: str,\n        access_token: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"\n        Encodes the specified claims into a JSON Web Token (JWT).\n\n        Parameters:\n            claims: A dictionary containing the claims to be included in the JWT.\n            secret_key: The secret key used to sign the JWT.\n            algorithm: The signing algorithm to be used for the JWT.\n            access_token: Optional parameter for additional handling of access tokens.\n\n        Returns:\n            str: A string representation of the encoded JWT.\n\n        Raises:\n             NotImplementedError: If this method is not implemented in a subclass.\n        \"\"\"\n\n        raise NotImplementedError\n\n    @abstractmethod\n    def decode(\n        self,\n        token: str,\n        secret_key: str,\n        algorithm: str,\n        access_token: Optional[str] = None,\n    ) -&gt; dict | None:\n        \"\"\"\n        Decodes a JSON Web Token (JWT) and validates its claims.\n\n        Parameters:\n            token: The JWT string to be decoded.\n            secret_key: The secret key used to validate the JWT signature.\n            algorithm: The signing algorithm used to verify the JWT,\n            access_token: Optional parameter for additional handling of access tokens.\n\n        Returns:\n            dicy: A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.\n\n        Raises:\n             NotImplementedError: If this method is not implemented in a subclass.\n        \"\"\"\n\n        raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/manager/#webtool.auth.manager.BaseJWTManager.encode","title":"encode  <code>abstractmethod</code>","text":"<pre><code>encode(claims, secret_key, algorithm, access_token=None)\n</code></pre> <p>Encodes the specified claims into a JSON Web Token (JWT).</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>dict</code> <p>A dictionary containing the claims to be included in the JWT.</p> required <code>secret_key</code> <code>str</code> <p>The secret key used to sign the JWT.</p> required <code>algorithm</code> <code>str</code> <p>The signing algorithm to be used for the JWT.</p> required <code>access_token</code> <code>Optional[str]</code> <p>Optional parameter for additional handling of access tokens.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the encoded JWT.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method is not implemented in a subclass.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>@abstractmethod\ndef encode(\n    self,\n    claims: dict,\n    secret_key: str,\n    algorithm: str,\n    access_token: Optional[str] = None,\n) -&gt; str:\n    \"\"\"\n    Encodes the specified claims into a JSON Web Token (JWT).\n\n    Parameters:\n        claims: A dictionary containing the claims to be included in the JWT.\n        secret_key: The secret key used to sign the JWT.\n        algorithm: The signing algorithm to be used for the JWT.\n        access_token: Optional parameter for additional handling of access tokens.\n\n    Returns:\n        str: A string representation of the encoded JWT.\n\n    Raises:\n         NotImplementedError: If this method is not implemented in a subclass.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/manager/#webtool.auth.manager.BaseJWTManager.decode","title":"decode  <code>abstractmethod</code>","text":"<pre><code>decode(token, secret_key, algorithm, access_token=None)\n</code></pre> <p>Decodes a JSON Web Token (JWT) and validates its claims.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT string to be decoded.</p> required <code>secret_key</code> <code>str</code> <p>The secret key used to validate the JWT signature.</p> required <code>algorithm</code> <code>str</code> <p>The signing algorithm used to verify the JWT,</p> required <code>access_token</code> <code>Optional[str]</code> <p>Optional parameter for additional handling of access tokens.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dicy</code> <code>dict | None</code> <p>A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.</p> <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>If this method is not implemented in a subclass.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>@abstractmethod\ndef decode(\n    self,\n    token: str,\n    secret_key: str,\n    algorithm: str,\n    access_token: Optional[str] = None,\n) -&gt; dict | None:\n    \"\"\"\n    Decodes a JSON Web Token (JWT) and validates its claims.\n\n    Parameters:\n        token: The JWT string to be decoded.\n        secret_key: The secret key used to validate the JWT signature.\n        algorithm: The signing algorithm used to verify the JWT,\n        access_token: Optional parameter for additional handling of access tokens.\n\n    Returns:\n        dicy: A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.\n\n    Raises:\n         NotImplementedError: If this method is not implemented in a subclass.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/manager/#webtool.auth.manager.JWTManager","title":"JWTManager","text":"<p>               Bases: <code>BaseJWTManager</code></p> <p>JWT manager for encoding and decoding JSON Web Tokens.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>class JWTManager(BaseJWTManager):\n    \"\"\"\n    JWT manager for encoding and decoding JSON Web Tokens.\n    \"\"\"\n\n    def __init__(self):\n        self.jwt = jwt.PyJWT(self._get_default_options())\n\n    @staticmethod\n    def _get_default_options() -&gt; dict[str, bool | list[str]]:\n        return {\n            \"verify_signature\": True,\n            \"verify_exp\": False,\n            \"verify_nbf\": True,\n            \"verify_iat\": True,\n            \"verify_aud\": True,\n            \"verify_iss\": True,\n            \"verify_sub\": True,\n            \"verify_jti\": True,\n            \"require\": [],\n        }\n\n    def encode(\n        self,\n        claims: dict,\n        secret_key: str,\n        algorithm: str,\n        access_token: Optional[str] = None,\n    ) -&gt; str:\n        \"\"\"\n        Encodes the specified claims into a JSON Web Token (JWT) with a specified expiration time.\n\n        Parameters:\n            claims: A dictionary containing the claims to be included in the JWT.\n            secret_key: The secret key used to sign the JWT.\n             algorithm: The signing algorithm to use for the JWT, defaults to 'ES384'.\n             access_token: Optional parameter for additional handling of access tokens.\n\n        Returns:\n            str: Json Web Token (JWT).\n        \"\"\"\n\n        return self.jwt.encode(claims, secret_key, algorithm=algorithm)\n\n    def decode(\n        self,\n        token: str,\n        secret_key: str,\n        algorithm: str,\n        access_token: Optional[str] = None,\n        raise_error: bool = False,\n    ) -&gt; dict | None:\n        \"\"\"\n        Decodes a JSON Web Token (JWT) and returns the claims if valid.\n\n        Parameters:\n            token: The JWT string to be decoded.\n            secret_key: The secret key used to validate the JWT signature.\n            algorithm: The signing algorithm used for verification JWT, defaults to 'ES384'.\n            access_token: Optional parameter for additional handling of access tokens.\n            raise_error: Optional parameter for additional handling of error messages.\n\n        Returns:\n            dict: A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.\n        \"\"\"\n\n        try:\n            return self.jwt.decode(\n                token,\n                secret_key,\n                algorithms=[algorithm],\n                access_token=access_token,\n            )\n        except jwt.InvalidTokenError as e:\n            if raise_error:\n                raise e\n            else:\n                return None\n</code></pre>"},{"location":"learn/jwt/manager/#webtool.auth.manager.JWTManager.jwt","title":"jwt  <code>instance-attribute</code>","text":"<pre><code>jwt = PyJWT(_get_default_options())\n</code></pre>"},{"location":"learn/jwt/manager/#webtool.auth.manager.JWTManager.encode","title":"encode","text":"<pre><code>encode(claims, secret_key, algorithm, access_token=None)\n</code></pre> <p>Encodes the specified claims into a JSON Web Token (JWT) with a specified expiration time.</p> <p>Parameters:</p> Name Type Description Default <code>claims</code> <code>dict</code> <p>A dictionary containing the claims to be included in the JWT.</p> required <code>secret_key</code> <code>str</code> <p>The secret key used to sign the JWT. algorithm: The signing algorithm to use for the JWT, defaults to 'ES384'. access_token: Optional parameter for additional handling of access tokens.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Json Web Token (JWT).</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>def encode(\n    self,\n    claims: dict,\n    secret_key: str,\n    algorithm: str,\n    access_token: Optional[str] = None,\n) -&gt; str:\n    \"\"\"\n    Encodes the specified claims into a JSON Web Token (JWT) with a specified expiration time.\n\n    Parameters:\n        claims: A dictionary containing the claims to be included in the JWT.\n        secret_key: The secret key used to sign the JWT.\n         algorithm: The signing algorithm to use for the JWT, defaults to 'ES384'.\n         access_token: Optional parameter for additional handling of access tokens.\n\n    Returns:\n        str: Json Web Token (JWT).\n    \"\"\"\n\n    return self.jwt.encode(claims, secret_key, algorithm=algorithm)\n</code></pre>"},{"location":"learn/jwt/manager/#webtool.auth.manager.JWTManager.decode","title":"decode","text":"<pre><code>decode(\n    token,\n    secret_key,\n    algorithm,\n    access_token=None,\n    raise_error=False,\n)\n</code></pre> <p>Decodes a JSON Web Token (JWT) and returns the claims if valid.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The JWT string to be decoded.</p> required <code>secret_key</code> <code>str</code> <p>The secret key used to validate the JWT signature.</p> required <code>algorithm</code> <code>str</code> <p>The signing algorithm used for verification JWT, defaults to 'ES384'.</p> required <code>access_token</code> <code>Optional[str]</code> <p>Optional parameter for additional handling of access tokens.</p> <code>None</code> <code>raise_error</code> <code>bool</code> <p>Optional parameter for additional handling of error messages.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict | None</code> <p>A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>def decode(\n    self,\n    token: str,\n    secret_key: str,\n    algorithm: str,\n    access_token: Optional[str] = None,\n    raise_error: bool = False,\n) -&gt; dict | None:\n    \"\"\"\n    Decodes a JSON Web Token (JWT) and returns the claims if valid.\n\n    Parameters:\n        token: The JWT string to be decoded.\n        secret_key: The secret key used to validate the JWT signature.\n        algorithm: The signing algorithm used for verification JWT, defaults to 'ES384'.\n        access_token: Optional parameter for additional handling of access tokens.\n        raise_error: Optional parameter for additional handling of error messages.\n\n    Returns:\n        dict: A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.\n    \"\"\"\n\n    try:\n        return self.jwt.decode(\n            token,\n            secret_key,\n            algorithms=[algorithm],\n            access_token=access_token,\n        )\n    except jwt.InvalidTokenError as e:\n        if raise_error:\n            raise e\n        else:\n            return None\n</code></pre>"},{"location":"learn/jwt/service/","title":"Auth - service","text":""},{"location":"learn/jwt/service/#webtool.auth.service.TokenData","title":"TokenData","text":"<p>               Bases: <code>TypedDict</code></p> Source code in <code>webtool/auth/service.py</code> <pre><code>class TokenData(TypedDict):\n    sub: str\n    exp: NotRequired[float]\n    iat: NotRequired[float]\n    jti: NotRequired[str]\n    scopes: NotRequired[list[str]]\n    extra: NotRequired[dict[str, Any]]\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.TokenData.sub","title":"sub  <code>instance-attribute</code>","text":"<pre><code>sub\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.TokenData.exp","title":"exp  <code>instance-attribute</code>","text":"<pre><code>exp\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.TokenData.iat","title":"iat  <code>instance-attribute</code>","text":"<pre><code>iat\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.TokenData.jti","title":"jti  <code>instance-attribute</code>","text":"<pre><code>jti\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.TokenData.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.TokenData.extra","title":"extra  <code>instance-attribute</code>","text":"<pre><code>extra\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.BaseJWTService","title":"BaseJWTService","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>webtool/auth/service.py</code> <pre><code>class BaseJWTService(ABC):\n    @abstractmethod\n    async def create_token(self, data: dict) -&gt; tuple[str, str]:\n        \"\"\"\n        Create Access and Refresh Tokens.\n\n        Parameters:\n            data: must include 'sub' field.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def validate_access_token(self, access_token: str, validate_exp=True) -&gt; TokenData | None:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def validate_refresh_token(\n        self, access_token: str, refresh_token: str, validate_exp=True\n    ) -&gt; TokenData | None:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def invalidate_token(self, access_token: str, refresh_token: str) -&gt; bool:\n        raise NotImplementedError\n\n    @abstractmethod\n    async def update_token(self, data: dict, access_token: str, refresh_token: str) -&gt; tuple[str, str] | None:\n        raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.BaseJWTService.create_token","title":"create_token  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create_token(data)\n</code></pre> <p>Create Access and Refresh Tokens.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>must include 'sub' field.</p> required Source code in <code>webtool/auth/service.py</code> <pre><code>@abstractmethod\nasync def create_token(self, data: dict) -&gt; tuple[str, str]:\n    \"\"\"\n    Create Access and Refresh Tokens.\n\n    Parameters:\n        data: must include 'sub' field.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.BaseJWTService.validate_access_token","title":"validate_access_token  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>validate_access_token(access_token, validate_exp=True)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>@abstractmethod\nasync def validate_access_token(self, access_token: str, validate_exp=True) -&gt; TokenData | None:\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.BaseJWTService.validate_refresh_token","title":"validate_refresh_token  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>validate_refresh_token(\n    access_token, refresh_token, validate_exp=True\n)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>@abstractmethod\nasync def validate_refresh_token(\n    self, access_token: str, refresh_token: str, validate_exp=True\n) -&gt; TokenData | None:\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.BaseJWTService.invalidate_token","title":"invalidate_token  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>invalidate_token(access_token, refresh_token)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>@abstractmethod\nasync def invalidate_token(self, access_token: str, refresh_token: str) -&gt; bool:\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.BaseJWTService.update_token","title":"update_token  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update_token(data, access_token, refresh_token)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>@abstractmethod\nasync def update_token(self, data: dict, access_token: str, refresh_token: str) -&gt; tuple[str, str] | None:\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService","title":"JWTService","text":"<p>               Bases: <code>BaseJWTService</code></p> <p>generate access token, refresh token</p> Source code in <code>webtool/auth/service.py</code> <pre><code>class JWTService(BaseJWTService):\n    \"\"\"\n    generate access token, refresh token\n    \"\"\"\n\n    _CACHE_TOKEN_PREFIX = \"jwt_\"\n    _CACHE_INVALIDATE_PREFIX = \"jwt_invalidate_\"\n\n    def __init__(\n        self,\n        cache: \"BaseCache\",\n        secret_key: str | bytes = \"\",\n        access_token_expire_time: int = 3600,\n        refresh_token_expire_time: int = 604800,\n        jwt_manager: BaseJWTManager | None = None,\n        algorithm: str | None = None,\n    ):\n        self._cache = cache\n        self._secret_key = secret_key\n        self._jwt_manager = jwt_manager or JWTManager()\n        self._json_encoder = ORJSONEncoder()\n        self._json_decoder = ORJSONDecoder()\n        self.algorithm = algorithm\n        self.access_token_expire_time = access_token_expire_time\n        self.refresh_token_expire_time = refresh_token_expire_time\n\n        self._private_key = None\n        self._public_key = None\n\n        if isinstance(self._secret_key, bytes):\n            key_cart = self._get_keys_from_secret()\n\n            if key_cart:\n                self._private_key, self._public_key, key_algorithm = key_cart\n                self._secret_key = None\n            else:\n                key_algorithm = self._get_symmetric_algorithm()\n        else:\n            key_algorithm = self._get_symmetric_algorithm()\n\n        self._verify_key_algorithm(key_algorithm)\n\n    def _get_symmetric_algorithm(self):\n        key_size = len(self._secret_key)\n\n        if key_size &lt; 48:\n            return \"HS256\"\n        elif key_size &lt; 64:\n            return \"HS384\"\n        else:\n            return \"HS512\"\n\n    def _get_keys_from_secret(self) -&gt; tuple[bytes, bytes, str] | None:\n        \"\"\"\n        Attempt to load keys from the secret key.\n        Returns a tuple of (private_key, public_key, key_algorithm).\n        \"\"\"\n        return load_key(self._secret_key)\n\n    def _verify_key_algorithm(self, key_algorithm: str) -&gt; None:\n        \"\"\"\n        Verify that the loaded key's algorithm matches the expected algorithm.\n        Raises ValueError if there is a mismatch.\n        \"\"\"\n        if self.algorithm:\n            if key_algorithm != self.algorithm:\n                raise ValueError(f\"Expected algorithm {key_algorithm}, but got {self.algorithm}\")\n        else:\n            self.algorithm = key_algorithm\n\n    @staticmethod\n    def _get_jti(validated_data: TokenData) -&gt; str:\n        return validated_data.get(\"jti\")\n\n    @staticmethod\n    def _get_exp(validated_data: TokenData) -&gt; float:\n        return validated_data.get(\"exp\")\n\n    @staticmethod\n    def _get_extra(validated_data: TokenData) -&gt; dict[str, Any]:\n        return validated_data.get(\"extra\")\n\n    @staticmethod\n    def _validate_exp(token_data: TokenData) -&gt; bool:\n        exp = token_data.get(\"exp\")\n        now = time.time()\n\n        return float(exp) &gt; now\n\n    @staticmethod\n    def _get_key(validated_data: TokenData) -&gt; str:\n        return f\"{JWTService._CACHE_TOKEN_PREFIX}{validated_data.get('jti')}\"\n\n    @staticmethod\n    def _create_jti() -&gt; str:\n        \"\"\"\n        Generates a unique identifier (JWT ID) for the token.\n        USE CRYPTOGRAPHICALLY SECURE PSEUDORANDOM STRING\n\n        :return: JWT ID (jti),\n        \"\"\"\n\n        jti = uuid4().hex\n        return jti\n\n    def _create_metadata(self, data: dict, ttl: float) -&gt; TokenData:\n        now = time.time()\n        token_data = data.copy()\n\n        token_data.setdefault(\"exp\", now + ttl)\n        token_data.setdefault(\"iat\", now)\n        token_data.setdefault(\"jti\", self._create_jti())\n        token_data.setdefault(\"extra\", {})\n\n        return token_data\n\n    def _create_token(self, data: dict, access_token: Optional[str] = None) -&gt; str:\n        return self._jwt_manager.encode(data, self._secret_key, self.algorithm, access_token)\n\n    def _decode_token(self, access_token: str, refresh_token: str | None = None) -&gt; TokenData:\n        if refresh_token:\n            return self._jwt_manager.decode(refresh_token, self._secret_key, self.algorithm, access_token)\n        else:\n            return self._jwt_manager.decode(access_token, self._secret_key, self.algorithm)\n\n    async def _save_token_data(self, access_data: TokenData, refresh_data: TokenData) -&gt; None:\n        access_jti = self._get_jti(access_data)\n\n        key = self._get_key(refresh_data)\n        val = self._get_extra(refresh_data)\n        val[\"access_jti\"] = access_jti\n        val = self._json_encoder.encode(val)\n\n        async with self._cache.lock(key, 100):\n            await self._cache.set(key, val, ex=self.refresh_token_expire_time)\n\n    async def _read_token_data(self, refresh_data: TokenData) -&gt; dict | None:\n        key = self._get_key(refresh_data)\n\n        async with self._cache.lock(key, 100):\n            val = await self._cache.get(key)\n\n        if val:\n            val = self._json_decoder.decode(val)\n\n        return val\n\n    async def _invalidate_token_data(self, validated_refresh_data: TokenData) -&gt; None:\n        refresh_exp = self._get_exp(validated_refresh_data)\n        refresh_db_data = await self._read_token_data(validated_refresh_data)\n        access_key = f\"{JWTService._CACHE_INVALIDATE_PREFIX}{refresh_db_data.get('access_jti')}\"\n        access_exp = refresh_exp - self.refresh_token_expire_time + self.access_token_expire_time\n        now = time.time()\n\n        if access_exp &gt; now:\n            await self._cache.set(access_key, 1, exat=int(access_exp) + 1, nx=True)\n\n        refresh_jti = self._get_key(validated_refresh_data)\n        await self._cache.delete(refresh_jti)\n\n    async def create_token(self, data: dict) -&gt; tuple[str, str]:\n        access_data = self._create_metadata(data, self.access_token_expire_time)\n        refresh_data = self._create_metadata(data, self.refresh_token_expire_time)\n\n        access_token = self._create_token(access_data)\n        refresh_token = self._create_token(refresh_data, access_token)\n        await self._save_token_data(access_data, refresh_data)\n\n        return access_token, refresh_token\n\n    async def validate_access_token(self, access_token: str, validate_exp=True) -&gt; TokenData | None:\n        access_data = self._decode_token(access_token)\n\n        if validate_exp and not self._validate_exp(access_data):\n            return None\n\n        access_jti = self._get_jti(access_data)\n        key = f\"{JWTService._CACHE_INVALIDATE_PREFIX}{access_jti}\"\n\n        if await self._cache.get(key):\n            return None\n\n        return access_data\n\n    async def validate_refresh_token(\n        self, access_token: str, refresh_token: str, validate_exp=True\n    ) -&gt; TokenData | None:\n        refresh_data = self._decode_token(access_token, refresh_token)\n        if validate_exp and not self._validate_exp(refresh_data):\n            return None\n\n        cached_refresh_data = await self._read_token_data(refresh_data)\n        if not cached_refresh_data:\n            return None\n\n        refresh_data[\"extra\"] |= cached_refresh_data\n        return refresh_data\n\n    async def invalidate_token(self, access_token: str, refresh_token: str) -&gt; bool:\n        refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n        if not refresh_data:\n            return False\n\n        await self._invalidate_token_data(refresh_data)\n        return True\n\n    async def update_token(self, data: dict, access_token: str, refresh_token: str) -&gt; tuple[str, str] | None:\n        refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n        if not refresh_data:\n            return None\n\n        await self._invalidate_token_data(refresh_data)\n\n        refresh_jti = self._get_jti(refresh_data)\n        async with self._cache.lock(refresh_jti, 100):\n            new_access_token, new_refresh_token = await self.create_token(data)\n\n        return new_access_token, new_refresh_token\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.algorithm","title":"algorithm  <code>instance-attribute</code>","text":"<pre><code>algorithm = algorithm\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.access_token_expire_time","title":"access_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>access_token_expire_time = access_token_expire_time\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.refresh_token_expire_time","title":"refresh_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>refresh_token_expire_time = refresh_token_expire_time\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.create_token","title":"create_token  <code>async</code>","text":"<pre><code>create_token(data)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def create_token(self, data: dict) -&gt; tuple[str, str]:\n    access_data = self._create_metadata(data, self.access_token_expire_time)\n    refresh_data = self._create_metadata(data, self.refresh_token_expire_time)\n\n    access_token = self._create_token(access_data)\n    refresh_token = self._create_token(refresh_data, access_token)\n    await self._save_token_data(access_data, refresh_data)\n\n    return access_token, refresh_token\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.validate_access_token","title":"validate_access_token  <code>async</code>","text":"<pre><code>validate_access_token(access_token, validate_exp=True)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_access_token(self, access_token: str, validate_exp=True) -&gt; TokenData | None:\n    access_data = self._decode_token(access_token)\n\n    if validate_exp and not self._validate_exp(access_data):\n        return None\n\n    access_jti = self._get_jti(access_data)\n    key = f\"{JWTService._CACHE_INVALIDATE_PREFIX}{access_jti}\"\n\n    if await self._cache.get(key):\n        return None\n\n    return access_data\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.validate_refresh_token","title":"validate_refresh_token  <code>async</code>","text":"<pre><code>validate_refresh_token(\n    access_token, refresh_token, validate_exp=True\n)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_refresh_token(\n    self, access_token: str, refresh_token: str, validate_exp=True\n) -&gt; TokenData | None:\n    refresh_data = self._decode_token(access_token, refresh_token)\n    if validate_exp and not self._validate_exp(refresh_data):\n        return None\n\n    cached_refresh_data = await self._read_token_data(refresh_data)\n    if not cached_refresh_data:\n        return None\n\n    refresh_data[\"extra\"] |= cached_refresh_data\n    return refresh_data\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.invalidate_token","title":"invalidate_token  <code>async</code>","text":"<pre><code>invalidate_token(access_token, refresh_token)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def invalidate_token(self, access_token: str, refresh_token: str) -&gt; bool:\n    refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n    if not refresh_data:\n        return False\n\n    await self._invalidate_token_data(refresh_data)\n    return True\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.JWTService.update_token","title":"update_token  <code>async</code>","text":"<pre><code>update_token(data, access_token, refresh_token)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def update_token(self, data: dict, access_token: str, refresh_token: str) -&gt; tuple[str, str] | None:\n    refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n    if not refresh_data:\n        return None\n\n    await self._invalidate_token_data(refresh_data)\n\n    refresh_jti = self._get_jti(refresh_data)\n    async with self._cache.lock(refresh_jti, 100):\n        new_access_token, new_refresh_token = await self.create_token(data)\n\n    return new_access_token, new_refresh_token\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService","title":"RedisJWTService","text":"<p>               Bases: <code>JWTService</code></p> Source code in <code>webtool/auth/service.py</code> <pre><code>class RedisJWTService(JWTService):\n    _LUA_SAVE_TOKEN_SCRIPT = \"\"\"\n    -- PARAMETERS\n    local refresh_token = KEYS[1]\n    local now = ARGV[1]\n    local access_jti = ARGV[2]\n    local refresh_token_expire_time = ARGV[3]\n\n    -- REFRESH TOKEN DATA EXTRACTION\n    refresh_token = cjson.decode(refresh_token)\n    local refresh_exp = refresh_token['exp']\n    local refresh_sub = refresh_token['sub']\n    local refresh_jti = refresh_token['jti']\n    local refresh_val = refresh_token['extra']\n\n    -- SAVE REFRESH TOKEN FOR VALIDATION\n    local key = \"jwt_\" .. refresh_jti\n    refresh_val['access_jti'] = access_jti\n    refresh_val = cjson.encode(refresh_val)\n    redis.call('SET', key, refresh_val, 'EXAT', math.floor(refresh_exp))\n\n    -- SAVE REFRESH TOKEN FOR SEARCH\n    key = \"jwt_sub_\" .. refresh_sub\n    redis.call('ZADD', key, now, refresh_jti)\n    redis.call(\"EXPIRE\", key, refresh_token_expire_time)\n    \"\"\"\n\n    _LUA_INVALIDATE_TOKEN_SCRIPT = \"\"\"\n    -- PARAMETERS\n    local refresh_token = KEYS[1]\n    local now = tonumber(ARGV[1])\n    local access_token_expire_time = tonumber(ARGV[2])\n    local refresh_token_expire_time = tonumber(ARGV[3])\n    local refresh_jti_to_invalidate = ARGV[4]\n    local access_jti\n    local key\n    local refresh_to_invalidate_issue_time\n\n    -- REFRESH TOKEN DATA EXTRACTION\n    refresh_token = cjson.decode(refresh_token)\n    local refresh_sub = refresh_token['sub']\n    local refresh_jti = refresh_token['jti']\n\n    if #refresh_jti_to_invalidate &gt; 0 then\n\n        -- CHECK REFRESH TOKEN DATA FOR SEARCH\n        key = \"jwt_sub_\" .. refresh_sub\n        refresh_to_invalidate_issue_time = redis.call('ZSCORE', key, refresh_jti_to_invalidate)\n        if not refresh_to_invalidate_issue_time then\n            return 0\n        end\n\n        -- CHECK REFRESH TOKEN DATA FOR VALIDATION\n        key = \"jwt_\" .. refresh_jti\n        local refresh_data_to_invalidate = redis.call('GET', key)\n        if not refresh_data_to_invalidate then\n            redis.call('ZREM', refresh_sub, refresh_jti_to_invalidate)\n            return 0\n        end\n\n        -- REFRESH TOKEN DATA EXTRACTION\n        refresh_data_to_invalidate = cjson.decode(refresh_data_to_invalidate)\n        access_jti = refresh_data_to_invalidate['access_jti']\n        refresh_jti = refresh_jti_to_invalidate\n    else\n\n        -- INVALIDATE ORIGINAL ACCESS, REFRESH TOKEN\n        access_jti = refresh_token['extra']['access_jti']\n        refresh_to_invalidate_issue_time = refresh_token['exp'] - refresh_token_expire_time\n    end\n\n    -- MARK THE ACCESS TOKEN AS EXPIRED\n    local access_exp = refresh_to_invalidate_issue_time + access_token_expire_time\n    if access_exp &gt; now then\n        key = \"jwt_invalidate_\" .. access_jti\n        redis.call('SET', key, 1, 'EXAT', math.ceil(access_exp))\n    end\n\n    -- DELETE REFRESH TOKEN DATA FOR VALIDATION\n    local key = \"jwt_\" .. refresh_jti\n    redis.call('DEL', key)\n\n    -- DELETE REFRESH TOKEN DATA FOR SEARCH\n    key = \"jwt_sub_\" .. refresh_sub\n    redis.call('ZREM', key, refresh_jti)\n\n    return 1\n    \"\"\"\n\n    _LUA_SEARCH_TOKEN_SCRIPT = \"\"\"\n    -- PARAMETERS\n    local refresh_token = KEYS[1]\n    local now = tonumber(ARGV[1])\n    local refresh_token_expire_time = tonumber(ARGV[2])\n    local key\n\n    -- REFRESH TOKEN DATA EXTRACTION\n    refresh_token = cjson.decode(refresh_token)\n    local refresh_sub = refresh_token['sub']\n\n    -- DELETE EXPIRED REFRESH TOKEN DATA FOR SEARCH\n    key = \"jwt_sub_\" .. refresh_sub\n    redis.call('ZREMRANGEBYSCORE', key, 0, now - refresh_token_expire_time)\n\n    -- RETURN REFRESH TOKENS OF SUB\n    return redis.call('ZRANGE', key, 0, -1)\n    \"\"\"\n\n    def __init__(\n        self,\n        cache: \"RedisCache\",\n        secret_key: str | bytes = \"\",\n        access_token_expire_time: int = 3600,\n        refresh_token_expire_time: int = 604800,\n        jwt_manager: BaseJWTManager | None = None,\n        algorithm: str | None = None,\n    ):\n        super().__init__(cache, secret_key, access_token_expire_time, refresh_token_expire_time, jwt_manager, algorithm)\n        self._save_script = self._cache.cache.register_script(RedisJWTService._LUA_SAVE_TOKEN_SCRIPT)\n        self._invalidate_script = self._cache.cache.register_script(RedisJWTService._LUA_INVALIDATE_TOKEN_SCRIPT)\n        self._search_script = self._cache.cache.register_script(RedisJWTService._LUA_SEARCH_TOKEN_SCRIPT)\n\n    async def _save_token_data(self, access_data: TokenData, refresh_data: TokenData) -&gt; None:\n        access_jti = self._get_jti(access_data)\n        refresh_jti = self._get_jti(refresh_data)\n        refresh_json = self._json_encoder.encode(refresh_data)\n\n        async with self._cache.lock(refresh_jti, 100):\n            await self._save_script(\n                keys=[refresh_json],\n                args=[\n                    time.time(),\n                    access_jti,\n                    self.refresh_token_expire_time,\n                ],\n            )\n\n    async def _invalidate_token_data(\n        self,\n        validated_refresh_data: TokenData,\n        refresh_jti_to_invalidate: str | None = None,\n    ) -&gt; bool:\n        refresh_json = self._json_encoder.encode(validated_refresh_data)\n\n        return await self._invalidate_script(\n            keys=[refresh_json],\n            args=[\n                time.time(),\n                self.access_token_expire_time,\n                self.refresh_token_expire_time,\n                refresh_jti_to_invalidate or b\"\",\n            ],\n        )\n\n    async def invalidate_token(\n        self,\n        access_token: str,\n        refresh_token: str,\n        refresh_jti_to_invalidate: str | None = None,\n    ) -&gt; bool:\n        refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n        if not refresh_data:\n            return False\n\n        if not refresh_jti_to_invalidate:\n            refresh_jti_to_invalidate = self._get_jti(refresh_data)\n\n        return await self._invalidate_token_data(refresh_data, refresh_jti_to_invalidate)\n\n    async def search_token(self, access_token: str, refresh_token: str):\n        refresh_data = self._decode_token(access_token, refresh_token)\n        refresh_json = self._json_encoder.encode(refresh_data)\n\n        return await self._search_script(\n            keys=[refresh_json],\n            args=[\n                time.time(),\n                self.refresh_token_expire_time,\n            ],\n        )\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.algorithm","title":"algorithm  <code>instance-attribute</code>","text":"<pre><code>algorithm = algorithm\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.access_token_expire_time","title":"access_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>access_token_expire_time = access_token_expire_time\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.refresh_token_expire_time","title":"refresh_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>refresh_token_expire_time = refresh_token_expire_time\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.create_token","title":"create_token  <code>async</code>","text":"<pre><code>create_token(data)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def create_token(self, data: dict) -&gt; tuple[str, str]:\n    access_data = self._create_metadata(data, self.access_token_expire_time)\n    refresh_data = self._create_metadata(data, self.refresh_token_expire_time)\n\n    access_token = self._create_token(access_data)\n    refresh_token = self._create_token(refresh_data, access_token)\n    await self._save_token_data(access_data, refresh_data)\n\n    return access_token, refresh_token\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.validate_access_token","title":"validate_access_token  <code>async</code>","text":"<pre><code>validate_access_token(access_token, validate_exp=True)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_access_token(self, access_token: str, validate_exp=True) -&gt; TokenData | None:\n    access_data = self._decode_token(access_token)\n\n    if validate_exp and not self._validate_exp(access_data):\n        return None\n\n    access_jti = self._get_jti(access_data)\n    key = f\"{JWTService._CACHE_INVALIDATE_PREFIX}{access_jti}\"\n\n    if await self._cache.get(key):\n        return None\n\n    return access_data\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.validate_refresh_token","title":"validate_refresh_token  <code>async</code>","text":"<pre><code>validate_refresh_token(\n    access_token, refresh_token, validate_exp=True\n)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_refresh_token(\n    self, access_token: str, refresh_token: str, validate_exp=True\n) -&gt; TokenData | None:\n    refresh_data = self._decode_token(access_token, refresh_token)\n    if validate_exp and not self._validate_exp(refresh_data):\n        return None\n\n    cached_refresh_data = await self._read_token_data(refresh_data)\n    if not cached_refresh_data:\n        return None\n\n    refresh_data[\"extra\"] |= cached_refresh_data\n    return refresh_data\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.update_token","title":"update_token  <code>async</code>","text":"<pre><code>update_token(data, access_token, refresh_token)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def update_token(self, data: dict, access_token: str, refresh_token: str) -&gt; tuple[str, str] | None:\n    refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n    if not refresh_data:\n        return None\n\n    await self._invalidate_token_data(refresh_data)\n\n    refresh_jti = self._get_jti(refresh_data)\n    async with self._cache.lock(refresh_jti, 100):\n        new_access_token, new_refresh_token = await self.create_token(data)\n\n    return new_access_token, new_refresh_token\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.invalidate_token","title":"invalidate_token  <code>async</code>","text":"<pre><code>invalidate_token(\n    access_token,\n    refresh_token,\n    refresh_jti_to_invalidate=None,\n)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def invalidate_token(\n    self,\n    access_token: str,\n    refresh_token: str,\n    refresh_jti_to_invalidate: str | None = None,\n) -&gt; bool:\n    refresh_data = await self.validate_refresh_token(access_token, refresh_token)\n\n    if not refresh_data:\n        return False\n\n    if not refresh_jti_to_invalidate:\n        refresh_jti_to_invalidate = self._get_jti(refresh_data)\n\n    return await self._invalidate_token_data(refresh_data, refresh_jti_to_invalidate)\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.RedisJWTService.search_token","title":"search_token  <code>async</code>","text":"<pre><code>search_token(access_token, refresh_token)\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def search_token(self, access_token: str, refresh_token: str):\n    refresh_data = self._decode_token(access_token, refresh_token)\n    refresh_json = self._json_encoder.encode(refresh_data)\n\n    return await self._search_script(\n        keys=[refresh_json],\n        args=[\n            time.time(),\n            self.refresh_token_expire_time,\n        ],\n    )\n</code></pre>"},{"location":"learn/jwt/service/#webtool.auth.service.main","title":"main  <code>async</code>","text":"<pre><code>main()\n</code></pre> Source code in <code>webtool/auth/service.py</code> <pre><code>async def main():\n    from webtool.cache.client import RedisCache\n\n    redis_jwt = RedisJWTService(RedisCache(\"redis://localhost:6379/0\"))\n\n    user = {\"sub\": \"100\"}\n\n    access, refresh = await redis_jwt.create_token(user)\n    print(access, refresh)\n\n    a_data = await redis_jwt.validate_access_token(access)\n    print(a_data)\n\n    r_data = await redis_jwt.validate_refresh_token(access, refresh)\n    print(r_data)\n\n    new_access, new_refresh = await redis_jwt.update_token(user, access, refresh)\n\n    print(await redis_jwt.update_token(user, access, refresh))\n\n    a_data = await redis_jwt.validate_access_token(access)\n    print(\"\ub9cc\ub8cc\ub41c\uac70\", a_data)\n\n    r_data = await redis_jwt.validate_refresh_token(access, refresh)\n    print(\"\ub9cc\ub8cc\ub41c \ub9ac\ud504\ub808\uc2dc\", r_data)\n\n    a_data = await redis_jwt.validate_access_token(new_access)\n    print(a_data)\n\n    r_data = await redis_jwt.validate_refresh_token(new_access, new_refresh)\n    print(r_data)\n\n    x = await redis_jwt.search_token(new_access, new_refresh)\n    print(x)\n\n    print(await redis_jwt.update_token(user, access, refresh))\n</code></pre>"},{"location":"learn/throttle/backend/","title":"throttle - backend","text":""},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseBackend","title":"BaseBackend","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for authentication backends. All authentication backends must inherit from this class.</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>class BaseBackend(ABC):\n    \"\"\"\n    Abstract base class for authentication backends.\n    All authentication backends must inherit from this class.\n    \"\"\"\n\n    @abstractmethod\n    async def authenticate(self, scope) -&gt; Any | None:\n        \"\"\"\n        Performs authentication using the request scope.\n\n        :param scope: ASGI request scope\n        :return: Authentication data or None\n        \"\"\"\n\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_identifier(self, authenticate_data: Any) -&gt; str:\n        \"\"\"\n        Extracts a unique identifier from the authenticated data.\n\n        :param authenticate_data: Data returned from authenticate() method\n        :return: String identifier\n        \"\"\"\n\n        raise NotImplementedError\n\n    @abstractmethod\n    def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n        \"\"\"\n        Extracts a scope from the authenticated data.\n\n        :param authenticate_data: Data returned from authenticate() method\n        :return: list of scope\n        \"\"\"\n\n        raise NotImplementedError\n\n    @staticmethod\n    @abstractmethod\n    def _callback():\n        \"\"\"\n        Callback method called when authentication fails\n        \"\"\"\n\n        raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseBackend.authenticate","title":"authenticate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using the request scope.</p> <p>:param scope: ASGI request scope :return: Authentication data or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\nasync def authenticate(self, scope) -&gt; Any | None:\n    \"\"\"\n    Performs authentication using the request scope.\n\n    :param scope: ASGI request scope\n    :return: Authentication data or None\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseBackend.get_identifier","title":"get_identifier  <code>abstractmethod</code>","text":"<pre><code>get_identifier(authenticate_data)\n</code></pre> <p>Extracts a unique identifier from the authenticated data.</p> <p>:param authenticate_data: Data returned from authenticate() method :return: String identifier</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\ndef get_identifier(self, authenticate_data: Any) -&gt; str:\n    \"\"\"\n    Extracts a unique identifier from the authenticated data.\n\n    :param authenticate_data: Data returned from authenticate() method\n    :return: String identifier\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseBackend.get_scope","title":"get_scope  <code>abstractmethod</code>","text":"<pre><code>get_scope(authenticate_data)\n</code></pre> <p>Extracts a scope from the authenticated data.</p> <p>:param authenticate_data: Data returned from authenticate() method :return: list of scope</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\ndef get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n    \"\"\"\n    Extracts a scope from the authenticated data.\n\n    :param authenticate_data: Data returned from authenticate() method\n    :return: list of scope\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseAnnoBackend","title":"BaseAnnoBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Base backend class for handling anonymous users</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>class BaseAnnoBackend(BaseBackend):\n    \"\"\"\n    Base backend class for handling anonymous users\n    \"\"\"\n\n    @abstractmethod\n    def verify_identity(self, *args, **kwargs) -&gt; Any:\n        \"\"\"\n        Method to verify the identity of anonymous users\n        \"\"\"\n\n        raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseAnnoBackend.authenticate","title":"authenticate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using the request scope.</p> <p>:param scope: ASGI request scope :return: Authentication data or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\nasync def authenticate(self, scope) -&gt; Any | None:\n    \"\"\"\n    Performs authentication using the request scope.\n\n    :param scope: ASGI request scope\n    :return: Authentication data or None\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseAnnoBackend.get_identifier","title":"get_identifier  <code>abstractmethod</code>","text":"<pre><code>get_identifier(authenticate_data)\n</code></pre> <p>Extracts a unique identifier from the authenticated data.</p> <p>:param authenticate_data: Data returned from authenticate() method :return: String identifier</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\ndef get_identifier(self, authenticate_data: Any) -&gt; str:\n    \"\"\"\n    Extracts a unique identifier from the authenticated data.\n\n    :param authenticate_data: Data returned from authenticate() method\n    :return: String identifier\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseAnnoBackend.get_scope","title":"get_scope  <code>abstractmethod</code>","text":"<pre><code>get_scope(authenticate_data)\n</code></pre> <p>Extracts a scope from the authenticated data.</p> <p>:param authenticate_data: Data returned from authenticate() method :return: list of scope</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\ndef get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n    \"\"\"\n    Extracts a scope from the authenticated data.\n\n    :param authenticate_data: Data returned from authenticate() method\n    :return: list of scope\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.BaseAnnoBackend.verify_identity","title":"verify_identity  <code>abstractmethod</code>","text":"<pre><code>verify_identity(*args, **kwargs)\n</code></pre> <p>Method to verify the identity of anonymous users</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>@abstractmethod\ndef verify_identity(self, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Method to verify the identity of anonymous users\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.IPBackend","title":"IPBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Authentication backend based on IP address</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>class IPBackend(BaseBackend):\n    \"\"\"\n    Authentication backend based on IP address\n    \"\"\"\n\n    async def authenticate(self, scope) -&gt; Any | None:\n        \"\"\"\n        Performs authentication using the client's IP address.\n\n        :param scope: ASGI request scope\n        :return: IP address or None\n        \"\"\"\n\n        client = scope.get(\"client\")\n        if client is None:\n            return self._callback()\n\n        return client[0]\n\n    def get_identifier(self, authenticate_data: Any) -&gt; str:\n        \"\"\"\n        Returns IP address as identifier.\n\n        :param authenticate_data: IP address\n        :return: IP address string\n        \"\"\"\n\n        return authenticate_data\n\n    def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n        \"\"\"\n        Returns scope.\n\n        :param authenticate_data: IP address\n        :return: None\n        \"\"\"\n\n        return None\n\n    @staticmethod\n    def _callback():\n        \"\"\"\n        Returns None when IP authentication fails.\n        \"\"\"\n\n        return None\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.IPBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using the client's IP address.</p> <p>:param scope: ASGI request scope :return: IP address or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; Any | None:\n    \"\"\"\n    Performs authentication using the client's IP address.\n\n    :param scope: ASGI request scope\n    :return: IP address or None\n    \"\"\"\n\n    client = scope.get(\"client\")\n    if client is None:\n        return self._callback()\n\n    return client[0]\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.IPBackend.get_identifier","title":"get_identifier","text":"<pre><code>get_identifier(authenticate_data)\n</code></pre> <p>Returns IP address as identifier.</p> <p>:param authenticate_data: IP address :return: IP address string</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_identifier(self, authenticate_data: Any) -&gt; str:\n    \"\"\"\n    Returns IP address as identifier.\n\n    :param authenticate_data: IP address\n    :return: IP address string\n    \"\"\"\n\n    return authenticate_data\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.IPBackend.get_scope","title":"get_scope","text":"<pre><code>get_scope(authenticate_data)\n</code></pre> <p>Returns scope.</p> <p>:param authenticate_data: IP address :return: None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n    \"\"\"\n    Returns scope.\n\n    :param authenticate_data: IP address\n    :return: None\n    \"\"\"\n\n    return None\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.SessionBackend","title":"SessionBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Session-based authentication backend</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>class SessionBackend(BaseBackend):\n    \"\"\"\n    Session-based authentication backend\n    \"\"\"\n\n    def __init__(self, session_name: str):\n        \"\"\"\n        :param session_name: Name of the session cookie\n        \"\"\"\n\n        self.session_name = session_name\n\n    def get_session(self, scope):\n        \"\"\"\n        Extracts session information from request scope.\n\n        :param scope: ASGI request scope\n        :return: Session value or None\n        \"\"\"\n\n        headers = scope.get(\"headers\")\n        if headers is None:\n            return None\n\n        cookie = _get_header_value(headers, \"cookie\")\n        if cookie is None:\n            return None\n\n        session = _get_cookie_value(cookie, self.session_name)\n        if session is None:\n            return None\n\n        return session\n\n    async def authenticate(self, scope) -&gt; Any | None:\n        \"\"\"\n        Performs authentication using session information.\n\n        :param scope: ASGI request scope\n        :return: Session information or None\n        \"\"\"\n\n        session = self.get_session(scope)\n        if not session:\n            return self._callback()\n\n        return session\n\n    def get_identifier(self, authenticate_data: Any) -&gt; str:\n        \"\"\"\n        Uses session information as identifier.\n\n        :param authenticate_data: Session information\n        :return: Session string\n        \"\"\"\n\n        return authenticate_data\n\n    def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n        \"\"\"\n        Returns scope.\n\n        :param authenticate_data: Session information\n        :return: None\n        \"\"\"\n\n        return None\n\n    @staticmethod\n    def _callback():\n        \"\"\"\n        Returns None when session authentication fails.\n        \"\"\"\n\n        return None\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.SessionBackend.session_name","title":"session_name  <code>instance-attribute</code>","text":"<pre><code>session_name = session_name\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.SessionBackend.get_session","title":"get_session","text":"<pre><code>get_session(scope)\n</code></pre> <p>Extracts session information from request scope.</p> <p>:param scope: ASGI request scope :return: Session value or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_session(self, scope):\n    \"\"\"\n    Extracts session information from request scope.\n\n    :param scope: ASGI request scope\n    :return: Session value or None\n    \"\"\"\n\n    headers = scope.get(\"headers\")\n    if headers is None:\n        return None\n\n    cookie = _get_header_value(headers, \"cookie\")\n    if cookie is None:\n        return None\n\n    session = _get_cookie_value(cookie, self.session_name)\n    if session is None:\n        return None\n\n    return session\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.SessionBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using session information.</p> <p>:param scope: ASGI request scope :return: Session information or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; Any | None:\n    \"\"\"\n    Performs authentication using session information.\n\n    :param scope: ASGI request scope\n    :return: Session information or None\n    \"\"\"\n\n    session = self.get_session(scope)\n    if not session:\n        return self._callback()\n\n    return session\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.SessionBackend.get_identifier","title":"get_identifier","text":"<pre><code>get_identifier(authenticate_data)\n</code></pre> <p>Uses session information as identifier.</p> <p>:param authenticate_data: Session information :return: Session string</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_identifier(self, authenticate_data: Any) -&gt; str:\n    \"\"\"\n    Uses session information as identifier.\n\n    :param authenticate_data: Session information\n    :return: Session string\n    \"\"\"\n\n    return authenticate_data\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.SessionBackend.get_scope","title":"get_scope","text":"<pre><code>get_scope(authenticate_data)\n</code></pre> <p>Returns scope.</p> <p>:param authenticate_data: Session information :return: None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n    \"\"\"\n    Returns scope.\n\n    :param authenticate_data: Session information\n    :return: None\n    \"\"\"\n\n    return None\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend","title":"AnnoSessionBackend","text":"<p>               Bases: <code>SessionBackend</code>, <code>BaseAnnoBackend</code></p> <p>Session backend for anonymous users. Automatically creates and assigns new sessions.</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>class AnnoSessionBackend(SessionBackend, BaseAnnoBackend):\n    \"\"\"\n    Session backend for anonymous users.\n    Automatically creates and assigns new sessions.\n    \"\"\"\n\n    def __init__(\n        self,\n        session_name,\n        max_age: int = 1209600,\n        secure: bool = True,\n        same_site: Literal[\"lax\", \"strict\", \"none\"] | None = \"lax\",\n        session_factory: Optional[Callable] = uuid4,\n    ):\n        \"\"\"\n        :param session_name: Name of the session cookie\n        :param max_age: Session expiration time (seconds)\n        :param secure: HTTPS only flag\n        :param same_site: SameSite cookie policy\n        :param session_factory: Session ID generation function\n        \"\"\"\n\n        super().__init__(session_name)\n\n        self.session_factory = session_factory\n        self.security_flags = f\"path=/; httponly; samesite={same_site}; Max-Age={max_age};\"\n        if secure:\n            self.security_flags += \" secure;\"\n\n    async def verify_identity(self, scope, send):\n        \"\"\"\n        Assigns new session to anonymous users and redirects.\n\n        :param scope: ASGI request scope\n        :param send: ASGI send function\n        \"\"\"\n\n        await send(\n            {\n                \"type\": \"http.response.start\",\n                \"status\": 307,\n                \"headers\": [\n                    (b\"location\", scope[\"path\"].encode()),\n                    (\n                        b\"Set-Cookie\",\n                        f\"{self.session_name}={self.session_factory().hex}; path=/; {self.security_flags}\".encode(),\n                    ),\n                ],\n            }\n        )\n        await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.session_name","title":"session_name  <code>instance-attribute</code>","text":"<pre><code>session_name = session_name\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.session_factory","title":"session_factory  <code>instance-attribute</code>","text":"<pre><code>session_factory = session_factory\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.security_flags","title":"security_flags  <code>instance-attribute</code>","text":"<pre><code>security_flags = f\"path=/; httponly; samesite={same_site}; Max-Age={max_age};\"\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using session information.</p> <p>:param scope: ASGI request scope :return: Session information or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; Any | None:\n    \"\"\"\n    Performs authentication using session information.\n\n    :param scope: ASGI request scope\n    :return: Session information or None\n    \"\"\"\n\n    session = self.get_session(scope)\n    if not session:\n        return self._callback()\n\n    return session\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.get_identifier","title":"get_identifier","text":"<pre><code>get_identifier(authenticate_data)\n</code></pre> <p>Uses session information as identifier.</p> <p>:param authenticate_data: Session information :return: Session string</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_identifier(self, authenticate_data: Any) -&gt; str:\n    \"\"\"\n    Uses session information as identifier.\n\n    :param authenticate_data: Session information\n    :return: Session string\n    \"\"\"\n\n    return authenticate_data\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.get_scope","title":"get_scope","text":"<pre><code>get_scope(authenticate_data)\n</code></pre> <p>Returns scope.</p> <p>:param authenticate_data: Session information :return: None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n    \"\"\"\n    Returns scope.\n\n    :param authenticate_data: Session information\n    :return: None\n    \"\"\"\n\n    return None\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.get_session","title":"get_session","text":"<pre><code>get_session(scope)\n</code></pre> <p>Extracts session information from request scope.</p> <p>:param scope: ASGI request scope :return: Session value or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_session(self, scope):\n    \"\"\"\n    Extracts session information from request scope.\n\n    :param scope: ASGI request scope\n    :return: Session value or None\n    \"\"\"\n\n    headers = scope.get(\"headers\")\n    if headers is None:\n        return None\n\n    cookie = _get_header_value(headers, \"cookie\")\n    if cookie is None:\n        return None\n\n    session = _get_cookie_value(cookie, self.session_name)\n    if session is None:\n        return None\n\n    return session\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.AnnoSessionBackend.verify_identity","title":"verify_identity  <code>async</code>","text":"<pre><code>verify_identity(scope, send)\n</code></pre> <p>Assigns new session to anonymous users and redirects.</p> <p>:param scope: ASGI request scope :param send: ASGI send function</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>async def verify_identity(self, scope, send):\n    \"\"\"\n    Assigns new session to anonymous users and redirects.\n\n    :param scope: ASGI request scope\n    :param send: ASGI send function\n    \"\"\"\n\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 307,\n            \"headers\": [\n                (b\"location\", scope[\"path\"].encode()),\n                (\n                    b\"Set-Cookie\",\n                    f\"{self.session_name}={self.session_factory().hex}; path=/; {self.security_flags}\".encode(),\n                ),\n            ],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend","title":"JWTBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>JWT (JSON Web Token) based authentication backend</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>class JWTBackend(BaseBackend):\n    \"\"\"\n    JWT (JSON Web Token) based authentication backend\n    \"\"\"\n\n    def __init__(self, jwt_service: \"BaseJWTService\"):\n        \"\"\"\n        :param jwt_service: Service object for JWT processing\n        \"\"\"\n\n        self.jwt_service = jwt_service\n\n    @staticmethod\n    def _get_authorization_scheme_param(\n        authorization_header_value: Optional[str],\n    ) -&gt; tuple[str, str]:\n        \"\"\"\n        Separates scheme and token from Authorization header.\n\n        :param authorization_header_value: Authorization header value\n        :return: (scheme, token) tuple\n        \"\"\"\n\n        if not authorization_header_value:\n            return \"\", \"\"\n        scheme, _, param = authorization_header_value.partition(\" \")\n\n        return scheme, param\n\n    def get_token(self, scope):\n        \"\"\"\n        Extracts JWT from request scope.\n\n        :param scope: ASGI request scope\n        :return: (scheme, token) tuple or None\n        \"\"\"\n\n        headers = scope.get(\"headers\")\n        if headers is None:\n            return None\n\n        authorization_value = _get_header_value(headers, \"authorization\")\n        if authorization_value is None:\n            return None\n\n        scheme, param = self._get_authorization_scheme_param(authorization_value)\n        if scheme.lower() != \"bearer\" or not param:\n            return None\n\n        return scheme, param\n\n    async def validate_token(self, token):\n        \"\"\"\n        Validates JWT.\n\n        :param token: JWT string\n        :return: Validated token data or None\n        \"\"\"\n\n        validated_token = await self.jwt_service.validate_access_token(token)\n\n        if validated_token is None:\n            return None\n\n        return validated_token\n\n    async def authenticate(self, scope) -&gt; Any | None:\n        \"\"\"\n        Performs authentication using JWT.\n\n        :param scope: ASGI request scope\n        :return: Validated token data or None\n        \"\"\"\n\n        token_data = self.get_token(scope)\n        if token_data is None:\n            return self._callback()\n\n        validated_token = await self.validate_token(token_data[1])\n        if validated_token is None:\n            return self._callback()\n\n        return validated_token\n\n    def get_identifier(self, authenticate_data: Any) -&gt; str:\n        \"\"\"\n        Extracts JTI (JWT ID) from JWT claims.\n\n        :param authenticate_data: JWT claims data\n        :return: JTI string\n        \"\"\"\n\n        return authenticate_data.get(\"sub\")\n\n    def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n        \"\"\"\n        Returns scope.\n\n        :param authenticate_data: JWT claims data\n        :return: scope\n        \"\"\"\n\n        return authenticate_data.get(\"scopes\")\n\n    @staticmethod\n    def _callback():\n        \"\"\"\n        Returns None when JWT authentication fails.\n        \"\"\"\n\n        return None\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend.jwt_service","title":"jwt_service  <code>instance-attribute</code>","text":"<pre><code>jwt_service = jwt_service\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend.get_token","title":"get_token","text":"<pre><code>get_token(scope)\n</code></pre> <p>Extracts JWT from request scope.</p> <p>:param scope: ASGI request scope :return: (scheme, token) tuple or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_token(self, scope):\n    \"\"\"\n    Extracts JWT from request scope.\n\n    :param scope: ASGI request scope\n    :return: (scheme, token) tuple or None\n    \"\"\"\n\n    headers = scope.get(\"headers\")\n    if headers is None:\n        return None\n\n    authorization_value = _get_header_value(headers, \"authorization\")\n    if authorization_value is None:\n        return None\n\n    scheme, param = self._get_authorization_scheme_param(authorization_value)\n    if scheme.lower() != \"bearer\" or not param:\n        return None\n\n    return scheme, param\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend.validate_token","title":"validate_token  <code>async</code>","text":"<pre><code>validate_token(token)\n</code></pre> <p>Validates JWT.</p> <p>:param token: JWT string :return: Validated token data or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>async def validate_token(self, token):\n    \"\"\"\n    Validates JWT.\n\n    :param token: JWT string\n    :return: Validated token data or None\n    \"\"\"\n\n    validated_token = await self.jwt_service.validate_access_token(token)\n\n    if validated_token is None:\n        return None\n\n    return validated_token\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using JWT.</p> <p>:param scope: ASGI request scope :return: Validated token data or None</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; Any | None:\n    \"\"\"\n    Performs authentication using JWT.\n\n    :param scope: ASGI request scope\n    :return: Validated token data or None\n    \"\"\"\n\n    token_data = self.get_token(scope)\n    if token_data is None:\n        return self._callback()\n\n    validated_token = await self.validate_token(token_data[1])\n    if validated_token is None:\n        return self._callback()\n\n    return validated_token\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend.get_identifier","title":"get_identifier","text":"<pre><code>get_identifier(authenticate_data)\n</code></pre> <p>Extracts JTI (JWT ID) from JWT claims.</p> <p>:param authenticate_data: JWT claims data :return: JTI string</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_identifier(self, authenticate_data: Any) -&gt; str:\n    \"\"\"\n    Extracts JTI (JWT ID) from JWT claims.\n\n    :param authenticate_data: JWT claims data\n    :return: JTI string\n    \"\"\"\n\n    return authenticate_data.get(\"sub\")\n</code></pre>"},{"location":"learn/throttle/backend/#webtool.throttle.backend.JWTBackend.get_scope","title":"get_scope","text":"<pre><code>get_scope(authenticate_data)\n</code></pre> <p>Returns scope.</p> <p>:param authenticate_data: JWT claims data :return: scope</p> Source code in <code>webtool/throttle/backend.py</code> <pre><code>def get_scope(self, authenticate_data: Any) -&gt; list[str] | None:\n    \"\"\"\n    Returns scope.\n\n    :param authenticate_data: JWT claims data\n    :return: scope\n    \"\"\"\n\n    return authenticate_data.get(\"scopes\")\n</code></pre>"},{"location":"learn/throttle/decorator/","title":"throttle - decorator","text":""},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.THROTTLE_RULE_ATTR_NAME","title":"THROTTLE_RULE_ATTR_NAME  <code>module-attribute</code>","text":"<pre><code>THROTTLE_RULE_ATTR_NAME = '_throttle_rules'\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule","title":"LimitRule","text":"<p>Represents a single rate limiting rule.</p> <p>Contains the conditions and parameters for a rate limit: - Maximum requests allowed - Time interval - Unique identifier - HTTP methods (optional) - User scopes (optional)</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>class LimitRule:\n    \"\"\"\n    Represents a single rate limiting rule.\n\n    Contains the conditions and parameters for a rate limit:\n    - Maximum requests allowed\n    - Time interval\n    - Unique identifier\n    - HTTP methods (optional)\n    - User scopes (optional)\n    \"\"\"\n\n    __slots__ = (\n        \"throttle_key\",\n        \"max_requests\",\n        \"interval\",\n        \"method\",\n        \"scopes\",\n        \"for_user\",\n        \"for_anno\",\n    )\n\n    def __init__(\n        self,\n        max_requests: int,\n        interval: int,\n        throttle_key: str,\n        method: Optional[list[str]],\n        scopes: Optional[list[str]],\n    ):\n        \"\"\"\n        :param max_requests: Maximum number of requests allowed\n        :param interval: Time interval in seconds\n        :param throttle_key: Unique identifier for this rule\n        :param method: List of HTTP methods this rule applies to\n        :param scopes: List of user scopes this rule applies to\n        \"\"\"\n\n        self.max_requests: int = max_requests\n        self.interval: int = interval\n        self.throttle_key: str = throttle_key\n        self.method: Optional[set[str]] = set(method)\n        self.scopes: Optional[set[str]] = set(scopes)\n        self.for_user: bool = \"user\" in scopes or (\"user\" in scopes) == (\"anno\" in scopes)\n        self.for_anno: bool = \"anno\" in scopes or (\"user\" in scopes) == (\"anno\" in scopes)\n\n        self.scopes.discard(\"user\")\n        self.scopes.discard(\"anno\")\n\n    def __repr__(self):\n        \"\"\"\n        String representation of the rule showing its configuration\n        \"\"\"\n\n        return (\n            f\"{self.max_requests} / {self.interval} \"\n            f\"{self.throttle_key:.20s}... {self.method} {self.scopes} \"\n            f\"for {'user' if self.for_user else 'anno' if self.for_anno else ''}\"\n        )\n\n    def is_enabled(\n        self,\n        scope,\n        anno_identifier: Any | None = None,\n        user_identifier: Any | None = None,\n        auth_scope: list[str] | None = None,\n    ):\n        \"\"\"\n        Checks if this rule should be applied based on request context.\n\n        :param scope: ASGI request scope\n        :param anno_identifier: Anonymous user identifier\n        :param user_identifier: Authenticated user identifier (optional)\n        :param auth_scope: List of user scopes this rule applies to\n        :return: Boolean indicating if rule should be applied\n        \"\"\"\n\n        if self.method and scope.get(\"method\") not in self.method:\n            return False\n\n        if not self.scopes or (auth_scope and set(auth_scope) &amp; self.scopes):\n            if user_identifier and self.for_user:\n                return True\n            elif anno_identifier and self.for_anno:\n                return True\n\n        return False\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.max_requests","title":"max_requests  <code>instance-attribute</code>","text":"<pre><code>max_requests = max_requests\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.interval","title":"interval  <code>instance-attribute</code>","text":"<pre><code>interval = interval\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.throttle_key","title":"throttle_key  <code>instance-attribute</code>","text":"<pre><code>throttle_key = throttle_key\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method = set(method)\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes = set(scopes)\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.for_user","title":"for_user  <code>instance-attribute</code>","text":"<pre><code>for_user = (\n    \"user\" in scopes or \"user\" in scopes == \"anno\" in scopes\n)\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.for_anno","title":"for_anno  <code>instance-attribute</code>","text":"<pre><code>for_anno = (\n    \"anno\" in scopes or \"user\" in scopes == \"anno\" in scopes\n)\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRule.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled(\n    scope,\n    anno_identifier=None,\n    user_identifier=None,\n    auth_scope=None,\n)\n</code></pre> <p>Checks if this rule should be applied based on request context.</p> <p>:param scope: ASGI request scope :param anno_identifier: Anonymous user identifier :param user_identifier: Authenticated user identifier (optional) :param auth_scope: List of user scopes this rule applies to :return: Boolean indicating if rule should be applied</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def is_enabled(\n    self,\n    scope,\n    anno_identifier: Any | None = None,\n    user_identifier: Any | None = None,\n    auth_scope: list[str] | None = None,\n):\n    \"\"\"\n    Checks if this rule should be applied based on request context.\n\n    :param scope: ASGI request scope\n    :param anno_identifier: Anonymous user identifier\n    :param user_identifier: Authenticated user identifier (optional)\n    :param auth_scope: List of user scopes this rule applies to\n    :return: Boolean indicating if rule should be applied\n    \"\"\"\n\n    if self.method and scope.get(\"method\") not in self.method:\n        return False\n\n    if not self.scopes or (auth_scope and set(auth_scope) &amp; self.scopes):\n        if user_identifier and self.for_user:\n            return True\n        elif anno_identifier and self.for_anno:\n            return True\n\n    return False\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager","title":"LimitRuleManager","text":"<p>Container class for managing multiple rate limit rules. Allows adding and checking rules for specific requests.</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>class LimitRuleManager:\n    \"\"\"\n    Container class for managing multiple rate limit rules.\n    Allows adding and checking rules for specific requests.\n    \"\"\"\n\n    __slots__ = (\"rules\",)\n\n    def __init__(self):\n        self.rules: set[LimitRule] = set()\n\n    def should_limit(\n        self,\n        scopes,\n        anno_identifier: Any | None = None,\n        user_identifier: Any | None = None,\n        auth_scope: list[str] | None = None,\n    ) -&gt; list[LimitRule]:\n        \"\"\"\n        Determines which rules should be applied for a given request.\n\n        :param scopes: ASGI request scope\n        :param anno_identifier: Anonymous user identifier (optional)\n        :param user_identifier: Authenticated user identifier (optional)\n        :param auth_scope: List of user scopes this rule applies to\n        :return: List of applicable rules\n        \"\"\"\n\n        rules = [rule for rule in self.rules if rule.is_enabled(scopes, anno_identifier, user_identifier, auth_scope)]\n\n        return rules\n\n    def add_rules(self, rule: LimitRule) -&gt; None:\n        \"\"\"\n        Adds a new rate limit rule to the collection.\n\n        :param rule: LimitRule instance to add\n        \"\"\"\n\n        self.rules.add(rule)\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = set()\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager.should_limit","title":"should_limit","text":"<pre><code>should_limit(\n    scopes,\n    anno_identifier=None,\n    user_identifier=None,\n    auth_scope=None,\n)\n</code></pre> <p>Determines which rules should be applied for a given request.</p> <p>:param scopes: ASGI request scope :param anno_identifier: Anonymous user identifier (optional) :param user_identifier: Authenticated user identifier (optional) :param auth_scope: List of user scopes this rule applies to :return: List of applicable rules</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def should_limit(\n    self,\n    scopes,\n    anno_identifier: Any | None = None,\n    user_identifier: Any | None = None,\n    auth_scope: list[str] | None = None,\n) -&gt; list[LimitRule]:\n    \"\"\"\n    Determines which rules should be applied for a given request.\n\n    :param scopes: ASGI request scope\n    :param anno_identifier: Anonymous user identifier (optional)\n    :param user_identifier: Authenticated user identifier (optional)\n    :param auth_scope: List of user scopes this rule applies to\n    :return: List of applicable rules\n    \"\"\"\n\n    rules = [rule for rule in self.rules if rule.is_enabled(scopes, anno_identifier, user_identifier, auth_scope)]\n\n    return rules\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager.add_rules","title":"add_rules","text":"<pre><code>add_rules(rule)\n</code></pre> <p>Adds a new rate limit rule to the collection.</p> <p>:param rule: LimitRule instance to add</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def add_rules(self, rule: LimitRule) -&gt; None:\n    \"\"\"\n    Adds a new rate limit rule to the collection.\n\n    :param rule: LimitRule instance to add\n    \"\"\"\n\n    self.rules.add(rule)\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.find_closure_rules_function","title":"find_closure_rules_function","text":"<pre><code>find_closure_rules_function(func)\n</code></pre> <p>Recursively finds a function with throttle rules in closure tree. Traverses through function closures using BFS.</p> <p>:param func: Function to search from :return: Function with throttle rules or None if not found</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def find_closure_rules_function(func):\n    \"\"\"\n    Recursively finds a function with throttle rules in closure tree.\n    Traverses through function closures using BFS.\n\n    :param func: Function to search from\n    :return: Function with throttle rules or None if not found\n    \"\"\"\n\n    queue = deque([func])\n    visited = set()\n\n    while queue:\n        current_func = queue.popleft()\n        if current_func in visited:\n            continue\n        visited.add(current_func)\n\n        if hasattr(current_func, THROTTLE_RULE_ATTR_NAME):\n            return current_func\n\n        if hasattr(current_func, \"__closure__\") and current_func.__closure__:\n            for cell in current_func.__closure__:\n                cell_content = cell.cell_contents\n                if callable(cell_content):\n                    queue.append(cell_content)\n\n    return None\n</code></pre>"},{"location":"learn/throttle/decorator/#webtool.throttle.decorator.limiter","title":"limiter","text":"<pre><code>limiter(\n    max_requests,\n    interval=3600,\n    throttle_key=None,\n    method=None,\n    scopes=None,\n)\n</code></pre> <p>Decorator for implementing rate limiting on functions.</p> <p>:param max_requests: Maximum number of requests allowed in the interval :param interval: Time interval in seconds (default: 3600) :param throttle_key: Custom key for the rate limit (default: function path) :param method: List of HTTP methods to apply limit to (optional) :param scopes: List of user scopes to apply limit to (optional) :return: Decorated function with rate limiting rules</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def limiter(\n    max_requests: Union[int, Callable[..., int]],\n    interval: int = 3600,\n    throttle_key: Optional[str] = None,\n    method: Optional[list[str]] = None,\n    scopes: Optional[list[str]] = None,\n):\n    \"\"\"\n    Decorator for implementing rate limiting on functions.\n\n    :param max_requests: Maximum number of requests allowed in the interval\n    :param interval: Time interval in seconds (default: 3600)\n    :param throttle_key: Custom key for the rate limit (default: function path)\n    :param method: List of HTTP methods to apply limit to (optional)\n    :param scopes: List of user scopes to apply limit to (optional)\n    :return: Decorated function with rate limiting rules\n    \"\"\"\n\n    def decorator(func):\n        exist_func = find_closure_rules_function(func)\n\n        key = throttle_key\n        if exist_func:\n            key = key or sha256(f\"{exist_func.__module__}{exist_func.__name__}{interval}{method}{scopes}\").hex()\n            if not hasattr(func, THROTTLE_RULE_ATTR_NAME):\n                exist_rules = getattr(exist_func, THROTTLE_RULE_ATTR_NAME)\n                setattr(func, THROTTLE_RULE_ATTR_NAME, exist_rules)\n        else:\n            key = key or sha256(f\"{func.__module__}{func.__name__}{interval}{method}{scopes}\").hex()\n            setattr(func, THROTTLE_RULE_ATTR_NAME, LimitRuleManager())\n\n        new_rule = LimitRule(\n            max_requests=max_requests,\n            interval=interval,\n            throttle_key=key,\n            method=[m.upper() for m in method] if method else [],\n            scopes=scopes or [],\n        )\n\n        getattr(func, THROTTLE_RULE_ATTR_NAME).add_rules(new_rule)\n\n        return func\n\n    return decorator\n</code></pre>"},{"location":"learn/throttle/limiter/","title":"throttle - limiter","text":""},{"location":"learn/throttle/limiter/#webtool.throttle.limiter.BaseLimiter","title":"BaseLimiter","text":"<p>               Bases: <code>ABC</code></p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>class BaseLimiter(ABC):\n    @abstractmethod\n    def is_deny(self, identifier: str, rules: list[LimitRule]) -&gt; list[float]:\n        \"\"\"\n        Checks if any rate limits are exceeded.\n\n        :param identifier: User or session identifier\n        :param rules: List of rate limit rules to check\n        :return: List of waiting times until rate limits reset (empty if not exceeded)\n        \"\"\"\n\n        raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/limiter/#webtool.throttle.limiter.BaseLimiter.is_deny","title":"is_deny  <code>abstractmethod</code>","text":"<pre><code>is_deny(identifier, rules)\n</code></pre> <p>Checks if any rate limits are exceeded.</p> <p>:param identifier: User or session identifier :param rules: List of rate limit rules to check :return: List of waiting times until rate limits reset (empty if not exceeded)</p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>@abstractmethod\ndef is_deny(self, identifier: str, rules: list[LimitRule]) -&gt; list[float]:\n    \"\"\"\n    Checks if any rate limits are exceeded.\n\n    :param identifier: User or session identifier\n    :param rules: List of rate limit rules to check\n    :return: List of waiting times until rate limits reset (empty if not exceeded)\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"learn/throttle/limiter/#webtool.throttle.limiter.RedisLimiter","title":"RedisLimiter","text":"<p>               Bases: <code>BaseLimiter</code></p> <p>Rate limiter implementation using Redis for distributed rate limiting.</p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>class RedisLimiter(BaseLimiter):\n    \"\"\"\n    Rate limiter implementation using Redis for distributed rate limiting.\n    \"\"\"\n\n    _LUA_LIMITER_SCRIPT = \"\"\"\n    -- Retrieve arguments\n    -- ruleset = {key: [limit, window_size], ...}\n    -- return = {key: [limit, current], ...}\n    local now = tonumber(ARGV[1])\n    local ruleset = cjson.decode(ARGV[2])\n\n    for i, key in ipairs(KEYS) do\n        -- Step 1: Remove expired requests from the sorted set\n        redis.call('ZREMRANGEBYSCORE', key, 0, now - ruleset[key][2])\n\n        -- Step 2: Count the number of requests within the valid time window\n        local amount = redis.call('ZCARD', key)\n\n        -- Step 3: Add the current request timestamp to the sorted set\n        if amount &lt;= ruleset[key][1] then\n            redis.call('ZADD', key, now, tostring(now))\n            amount = amount + 1\n        end\n\n        -- Step 4: Set the TTL for the key\n        redis.call(\"EXPIRE\", key, ruleset[key][2])\n        ruleset[key][2] = amount\n        ruleset[key][3] = redis.call(\"ZRANGE\", key, -1, -1)[1]\n    end\n\n    return cjson.encode(ruleset)\n    \"\"\"\n\n    def __init__(self, redis_cache: RedisCache):\n        \"\"\"\n        :param redis: Redis client instance\n        \"\"\"\n\n        self._cache = redis_cache.cache\n        self._redis_function = self._cache.register_script(RedisLimiter._LUA_LIMITER_SCRIPT)\n        self._json_encoder = ORJSONEncoder()\n        self._json_decoder = ORJSONDecoder()\n\n    @staticmethod\n    def _get_ruleset(identifier: str, rules: list[LimitRule]) -&gt; dict[str, tuple[int, int]]:\n        \"\"\"\n        Constructs a ruleset dictionary mapping keys to limits and intervals.\n\n        :param identifier: User or session identifier\n        :param rules: List of rate limit rules to apply\n        :return: Dictionary of {key: (max_requests, interval)}\n        \"\"\"\n\n        ruleset = {identifier + rule.throttle_key: (rule.max_requests, rule.interval) for rule in rules}\n\n        return ruleset\n\n    async def _get_limits(self, ruleset) -&gt; dict[str, list[int, int]]:\n        \"\"\"\n        Executes the rate limiting Lua script in Redis.\n\n        :param ruleset: Dictionary of rate limit rules\n        :return: Dictionary of updated counts and timestamps\n        \"\"\"\n\n        now = asyncio.get_running_loop().time()\n\n        result = await self._redis_function(keys=list(ruleset.keys()), args=[now, self._json_encoder.encode(ruleset)])\n        result = self._json_decoder.decode(result)\n\n        return result\n\n    async def is_deny(self, identifier: str, rules: list[LimitRule]) -&gt; list[float]:\n        \"\"\"\n        Checks if any rate limits are exceeded.\n\n        :param identifier: User or session identifier\n        :param rules: List of rate limit rules to check\n        :return: List of waiting times until rate limits reset (empty if not exceeded)\n        \"\"\"\n\n        ruleset = self._get_ruleset(identifier, rules)\n\n        result = await self._get_limits(ruleset)\n        now = asyncio.get_running_loop().time()\n        deny = [float(val[2]) + ruleset[key][1] - now for key, val in result.items() if val[0] &lt; val[1]]\n\n        return deny\n</code></pre>"},{"location":"learn/throttle/limiter/#webtool.throttle.limiter.RedisLimiter.is_deny","title":"is_deny  <code>async</code>","text":"<pre><code>is_deny(identifier, rules)\n</code></pre> <p>Checks if any rate limits are exceeded.</p> <p>:param identifier: User or session identifier :param rules: List of rate limit rules to check :return: List of waiting times until rate limits reset (empty if not exceeded)</p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>async def is_deny(self, identifier: str, rules: list[LimitRule]) -&gt; list[float]:\n    \"\"\"\n    Checks if any rate limits are exceeded.\n\n    :param identifier: User or session identifier\n    :param rules: List of rate limit rules to check\n    :return: List of waiting times until rate limits reset (empty if not exceeded)\n    \"\"\"\n\n    ruleset = self._get_ruleset(identifier, rules)\n\n    result = await self._get_limits(ruleset)\n    now = asyncio.get_running_loop().time()\n    deny = [float(val[2]) + ruleset[key][1] - now for key, val in result.items() if val[0] &lt; val[1]]\n\n    return deny\n</code></pre>"},{"location":"learn/throttle/middleware/","title":"throttle - middleware","text":""},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware","title":"LimitMiddleware","text":"<p>Middleware for implementing rate limiting in ASGI applications.</p> <p>This middleware supports both authenticated and anonymous users, applying rate limits based on user identifiers or session IDs.</p> Source code in <code>webtool/throttle/middleware.py</code> <pre><code>class LimitMiddleware:\n    \"\"\"\n    Middleware for implementing rate limiting in ASGI applications.\n\n    This middleware supports both authenticated and anonymous users,\n    applying rate limits based on user identifiers or session IDs.\n    \"\"\"\n\n    def __init__(\n        self,\n        app,\n        cache,\n        auth_backend: \"BaseBackend\",\n        anno_backend: \"BaseAnnoBackend\" = None,\n    ) -&gt; None:\n        \"\"\"\n        :param app: ASGI application\n        :param cache: Cache client instance for storing rate limit data\n        :param auth_backend: Authentication backend for identifying users\n        :param anno_backend: Backend for handling anonymous users (defaults to AnnoSessionBackend)\n        \"\"\"\n\n        self.app = app\n        self.limiter = RedisLimiter(cache)\n        self.limit = None\n        self.auth_backend = auth_backend\n        self.anno_backend = anno_backend or AnnoSessionBackend(\"th-session\")\n\n    async def __call__(self, scope, receive, send):\n        \"\"\"\n        Main middleware handler that processes each request.\n\n        :param scope: ASGI request scope\n        :param receive: ASGI receive function\n        :param send: ASGI send function\n        \"\"\"\n\n        # http check\n        if scope[\"type\"] != \"http\":\n            return await self.app(scope, receive, send)\n\n        # find handler\n        routes = scope[\"app\"].routes\n        handler = _find_route_handler(routes, scope)\n        if handler is None:\n            return await self.app(scope, receive, send)\n\n        # find limit rule manager\n        handler = find_closure_rules_function(handler)\n        if handler is None:\n            return await self.app(scope, receive, send)\n\n        manager: LimitRuleManager = getattr(handler, THROTTLE_RULE_ATTR_NAME)\n\n        # auth check\n        user_data = await self.auth_backend.authenticate(scope)\n        if user_data is not None:\n            identifier = self.auth_backend.get_identifier(user_data)\n            user_scope = self.auth_backend.get_scope(user_data)\n            rules = manager.should_limit(scope, user_identifier=identifier, auth_scope=user_scope)\n            return await self.apply(scope, receive, send, identifier, rules)\n\n        # anno check\n        anno_data = await self.anno_backend.authenticate(scope)\n        if anno_data is not None:\n            identifier = self.anno_backend.get_identifier(anno_data)\n            anno_scope = self.anno_backend.get_scope(anno_data)\n            rules = manager.should_limit(scope, anno_identifier=identifier, auth_scope=anno_scope)\n            return await self.apply(scope, receive, send, identifier, rules)\n\n        # issue limit identifier\n        return await self.anno_backend.verify_identity(scope, send)\n\n    async def apply(self, scope, receive, send, identifier: str, rules: list[\"LimitRule\"]):\n        \"\"\"\n        Applies rate limiting rules and handles the request.\n\n        :param scope: ASGI request scope\n        :param receive: ASGI receive function\n        :param send: ASGI send function\n        :param identifier: ASGI identifier string\n        :param rules: List of rate limit rules\n\n        :return: Response from app or rate limit exceeded response\n        \"\"\"\n\n        if rules:\n            deny = await self.limiter.is_deny(identifier, rules)\n            if deny:\n                return await _default_callback(scope, send, int(max(deny)))\n\n        return await self.app(scope, receive, send)\n</code></pre>"},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.limiter","title":"limiter  <code>instance-attribute</code>","text":"<pre><code>limiter = RedisLimiter(cache)\n</code></pre>"},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.limit","title":"limit  <code>instance-attribute</code>","text":"<pre><code>limit = None\n</code></pre>"},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.auth_backend","title":"auth_backend  <code>instance-attribute</code>","text":"<pre><code>auth_backend = auth_backend\n</code></pre>"},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.anno_backend","title":"anno_backend  <code>instance-attribute</code>","text":"<pre><code>anno_backend = anno_backend or AnnoSessionBackend(\n    \"th-session\"\n)\n</code></pre>"},{"location":"learn/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.apply","title":"apply  <code>async</code>","text":"<pre><code>apply(scope, receive, send, identifier, rules)\n</code></pre> <p>Applies rate limiting rules and handles the request.</p> <p>:param scope: ASGI request scope :param receive: ASGI receive function :param send: ASGI send function :param identifier: ASGI identifier string :param rules: List of rate limit rules</p> <p>:return: Response from app or rate limit exceeded response</p> Source code in <code>webtool/throttle/middleware.py</code> <pre><code>async def apply(self, scope, receive, send, identifier: str, rules: list[\"LimitRule\"]):\n    \"\"\"\n    Applies rate limiting rules and handles the request.\n\n    :param scope: ASGI request scope\n    :param receive: ASGI receive function\n    :param send: ASGI send function\n    :param identifier: ASGI identifier string\n    :param rules: List of rate limit rules\n\n    :return: Response from app or rate limit exceeded response\n    \"\"\"\n\n    if rules:\n        deny = await self.limiter.is_deny(identifier, rules)\n        if deny:\n            return await _default_callback(scope, send, int(max(deny)))\n\n    return await self.app(scope, receive, send)\n</code></pre>"},{"location":"resources/CONTRIBUTING/","title":"Development - Contributing","text":""},{"location":"resources/CONTRIBUTING/#developing","title":"Developing","text":"<p>If you already cloned the webtool repository and you want to deep dive in the code, here are some guidelines to set up your environment.</p>"},{"location":"resources/CONTRIBUTING/#virtual-environment","title":"Virtual environment","text":"<p>Follow the instructions to create and activate a virtual environment with Poetry for the internal code of webtool.</p>"},{"location":"resources/CONTRIBUTING/#install-requirements-using-poetry","title":"Install requirements using poetry","text":"<p>After activating the environment, install the required packages:</p> <pre><code> poetry install\n</code></pre>"},{"location":"resources/CONTRIBUTING/#using-your-local-webtool","title":"Using your local Webtool","text":"<p>If you create a Python file that imports and uses Webtool, and run it with the Python from your local environment, it will use your cloned local Webtool source code.</p> <p>And if you update that local Webtool source code when you run that Python file again, it will use the fresh version of Webtool you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p>"},{"location":"resources/CONTRIBUTING/#format-the-code","title":"Format the code","text":"<p>There is a script that you can run that will format and clean all your code:</p> <pre><code>poetry run ruff check\n</code></pre> <p>There is a script that you can run locally to test all the code and generate coverage reports:</p> <pre><code>poetry run coverage run --omit=\"tests*\" -m pytest\n</code></pre>"},{"location":"resources/CONTRIBUTING/#docs","title":"Docs","text":"<p>First, make sure you set up your environment as described above, that will install all the requirements.</p>"},{"location":"resources/CONTRIBUTING/#docs-live","title":"Docs live","text":"<p>During local development, there is a script that builds the site and checks for any changes, live-reloading:</p> <pre><code>mkdocs serve\n</code></pre> <p>It will serve the documentation on http://127.0.0.1:8000.</p> <p>You can also run docs live with other port</p> <pre><code>mkdocs serve -a localhost:8001\n</code></pre> <p>That way, you can edit the documentation/source files and see the changes live.</p>"},{"location":"resources/CONTRIBUTING/#docs-structure","title":"Docs Structure","text":"<p>The documentation uses MkDocs.</p>"}]}