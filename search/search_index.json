{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebTool(Alpha)","text":"<p>WebTool is Well-Architected FastAPI/Starlette library for authentication, throttling, caching, logging, and utilities.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install webtool\n</code></pre> <pre><code>poetry add webtool\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#authentication","title":"Authentication","text":"<p>JWT token management system with Redis-backed refresh tokens.</p> <pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache_client = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache_client)\n\n\nasync def get_token():\n    access, refresh = jwt_service.create_token({\"sub\": 123, \"scope\": [\"write\"]})\n    return access, refresh\n</code></pre>"},{"location":"#throttling","title":"Throttling","text":"<p>Rate limiting system for FastAPI/Starlette applications.</p> <pre><code>from fastapi import FastAPI\nfrom starlette.middleware import Middleware\nfrom webtool.auth import JWTService\nfrom webtool.cache import RedisCache\nfrom webtool.throttle import limiter, LimitMiddleware, JWTBackend\n\ncache = RedisCache(\"redis://127.0.0.1:6379/0\")\njwt_backend = JWTBackend(JWTService(cache, secret_key=\"test\"))\n\napp = FastAPI(\n    middleware=[\n        Middleware(\n            LimitMiddleware,\n            cache=cache,\n            auth_backend=jwt_backend,\n        ),\n    ],\n)\n\n\n@app.get(\"/api/resource\")\n@limiter(max_requests=50, interval=3600, scopes=[\"user\"])\n@limiter(max_requests=10, interval=3600, scopes=[\"anno\"])\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#msgpack-response","title":"MsgPack Response","text":"<p>MessagePack-based response.</p> <pre><code>from webtool.utils import MsgSpecJSONResponse\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    default_response_class=MsgSpecJSONResponse,\n)\n\n\n@app.get(\"/api/resource\")\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache-2.0 License.</p>"},{"location":"reference/auth/backend/","title":"throttle - backend","text":""},{"location":"reference/auth/backend/#webtool.auth.backend.BaseBackend","title":"BaseBackend","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for authentication backends. All authentication backends must inherit from this class.</p>"},{"location":"reference/auth/backend/#webtool.auth.backend.BaseBackend.authenticate","title":"authenticate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using the request scope.</p> <p>:param scope: ASGI request scope :return: Authentication data or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>@abstractmethod\nasync def authenticate(self, scope) -&gt; AuthData | None:\n    \"\"\"\n    Performs authentication using the request scope.\n\n    :param scope: ASGI request scope\n    :return: Authentication data or None\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.BaseAnnoBackend","title":"BaseAnnoBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Base backend class for handling anonymous users</p>"},{"location":"reference/auth/backend/#webtool.auth.backend.BaseAnnoBackend.authenticate","title":"authenticate  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using the request scope.</p> <p>:param scope: ASGI request scope :return: Authentication data or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>@abstractmethod\nasync def authenticate(self, scope) -&gt; AuthData | None:\n    \"\"\"\n    Performs authentication using the request scope.\n\n    :param scope: ASGI request scope\n    :return: Authentication data or None\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.BaseAnnoBackend.verify_identity","title":"verify_identity  <code>abstractmethod</code>","text":"<pre><code>verify_identity(*args, **kwargs)\n</code></pre> <p>Method to verify the identity of anonymous users</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>@abstractmethod\ndef verify_identity(self, *args, **kwargs) -&gt; Any:\n    \"\"\"\n    Method to verify the identity of anonymous users\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.IPBackend","title":"IPBackend","text":"<p>               Bases: <code>BaseBackend</code></p> <p>Authentication backend based on IP address</p>"},{"location":"reference/auth/backend/#webtool.auth.backend.IPBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using the client's IP address.</p> <p>:param scope: ASGI request scope :return: IP address or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; AuthData | None:\n    \"\"\"\n    Performs authentication using the client's IP address.\n\n    :param scope: ASGI request scope\n    :return: IP address or None\n    \"\"\"\n\n    client = scope.get(\"client\")\n    if client is None:\n        return self._callback()\n\n    auth = AuthData(identifier=client[0])\n\n    return auth\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.SessionBackend","title":"SessionBackend","text":"<pre><code>SessionBackend(session_name)\n</code></pre> <p>               Bases: <code>BaseBackend</code></p> <p>Session-based authentication backend</p> <p>:param session_name: Name of the session cookie</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>def __init__(self, session_name: str):\n    \"\"\"\n    :param session_name: Name of the session cookie\n    \"\"\"\n\n    self.session_name = session_name\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.SessionBackend.session_name","title":"session_name  <code>instance-attribute</code>","text":"<pre><code>session_name = session_name\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.SessionBackend.get_session","title":"get_session","text":"<pre><code>get_session(scope)\n</code></pre> <p>Extracts session information from request scope.</p> <p>:param scope: ASGI request scope :return: Session value or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>def get_session(self, scope):\n    \"\"\"\n    Extracts session information from request scope.\n\n    :param scope: ASGI request scope\n    :return: Session value or None\n    \"\"\"\n\n    headers = scope.get(\"headers\")\n    if headers is None:\n        return None\n\n    cookie = _get_header_value(headers, \"cookie\")\n    if cookie is None:\n        return None\n\n    session = _get_cookie_value(cookie, self.session_name)\n    if session is None:\n        return None\n\n    return session\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.SessionBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using session information.</p> <p>:param scope: ASGI request scope :return: Session information or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; AuthData | None:\n    \"\"\"\n    Performs authentication using session information.\n\n    :param scope: ASGI request scope\n    :return: Session information or None\n    \"\"\"\n\n    session = self.get_session(scope)\n    if not session:\n        return self._callback()\n\n    auth = AuthData(identifier=session)\n\n    return auth\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend","title":"AnnoSessionBackend","text":"<pre><code>AnnoSessionBackend(\n    session_name,\n    max_age=1209600,\n    secure=True,\n    same_site=\"lax\",\n    session_factory=uuid4,\n)\n</code></pre> <p>               Bases: <code>SessionBackend</code>, <code>BaseAnnoBackend</code></p> <p>Session backend for anonymous users. Automatically creates and assigns new sessions.</p> <p>:param session_name: Name of the session cookie :param max_age: Session expiration time (seconds) :param secure: HTTPS only flag :param same_site: SameSite cookie policy :param session_factory: Session ID generation function</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>def __init__(\n    self,\n    session_name,\n    max_age: int = 1209600,\n    secure: bool = True,\n    same_site: Literal[\"lax\", \"strict\", \"none\"] | None = \"lax\",\n    session_factory: Optional[Callable] = uuid4,\n):\n    \"\"\"\n    :param session_name: Name of the session cookie\n    :param max_age: Session expiration time (seconds)\n    :param secure: HTTPS only flag\n    :param same_site: SameSite cookie policy\n    :param session_factory: Session ID generation function\n    \"\"\"\n\n    super().__init__(session_name)\n\n    self.session_factory = session_factory\n    self.security_flags = f\"path=/; httponly; samesite={same_site}; Max-Age={max_age};\"\n    if secure:\n        self.security_flags += \" secure;\"\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend.session_name","title":"session_name  <code>instance-attribute</code>","text":"<pre><code>session_name = session_name\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend.session_factory","title":"session_factory  <code>instance-attribute</code>","text":"<pre><code>session_factory = session_factory\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend.security_flags","title":"security_flags  <code>instance-attribute</code>","text":"<pre><code>security_flags = f\"path=/; httponly; samesite={same_site}; Max-Age={max_age};\"\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using session information.</p> <p>:param scope: ASGI request scope :return: Session information or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; AuthData | None:\n    \"\"\"\n    Performs authentication using session information.\n\n    :param scope: ASGI request scope\n    :return: Session information or None\n    \"\"\"\n\n    session = self.get_session(scope)\n    if not session:\n        return self._callback()\n\n    auth = AuthData(identifier=session)\n\n    return auth\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend.get_session","title":"get_session","text":"<pre><code>get_session(scope)\n</code></pre> <p>Extracts session information from request scope.</p> <p>:param scope: ASGI request scope :return: Session value or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>def get_session(self, scope):\n    \"\"\"\n    Extracts session information from request scope.\n\n    :param scope: ASGI request scope\n    :return: Session value or None\n    \"\"\"\n\n    headers = scope.get(\"headers\")\n    if headers is None:\n        return None\n\n    cookie = _get_header_value(headers, \"cookie\")\n    if cookie is None:\n        return None\n\n    session = _get_cookie_value(cookie, self.session_name)\n    if session is None:\n        return None\n\n    return session\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.AnnoSessionBackend.verify_identity","title":"verify_identity  <code>async</code>","text":"<pre><code>verify_identity(scope, send)\n</code></pre> <p>Assigns new session to anonymous users and redirects.</p> <p>:param scope: ASGI request scope :param send: ASGI send function</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>async def verify_identity(self, scope, send):\n    \"\"\"\n    Assigns new session to anonymous users and redirects.\n\n    :param scope: ASGI request scope\n    :param send: ASGI send function\n    \"\"\"\n\n    await send(\n        {\n            \"type\": \"http.response.start\",\n            \"status\": 307,\n            \"headers\": [\n                (b\"location\", scope[\"path\"].encode()),\n                (\n                    b\"Set-Cookie\",\n                    f\"{self.session_name}={self.session_factory().hex}; path=/; {self.security_flags}\".encode(),\n                ),\n            ],\n        }\n    )\n    await send({\"type\": \"http.response.body\", \"body\": b\"\"})\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.JWTBackend","title":"JWTBackend","text":"<pre><code>JWTBackend(jwt_service)\n</code></pre> <p>               Bases: <code>BaseBackend</code></p> <p>JWT (JSON Web Token) based authentication backend</p> <p>:param jwt_service: Service object for JWT processing</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>def __init__(self, jwt_service: \"BaseJWTService\"):\n    \"\"\"\n    :param jwt_service: Service object for JWT processing\n    \"\"\"\n\n    self.jwt_service = jwt_service\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.JWTBackend.jwt_service","title":"jwt_service  <code>instance-attribute</code>","text":"<pre><code>jwt_service = jwt_service\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.JWTBackend.validate_token","title":"validate_token  <code>async</code>","text":"<pre><code>validate_token(token)\n</code></pre> <p>Validates JWT.</p> <p>:param token: JWT string :return: Validated token data or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>async def validate_token(self, token):\n    \"\"\"\n    Validates JWT.\n\n    :param token: JWT string\n    :return: Validated token data or None\n    \"\"\"\n\n    validated_token = await self.jwt_service.validate_access_token(token)\n\n    if validated_token is None:\n        return None\n\n    if validated_token.get(\"sub\") is None:\n        return None\n\n    return validated_token\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.JWTBackend.authenticate","title":"authenticate  <code>async</code>","text":"<pre><code>authenticate(scope)\n</code></pre> <p>Performs authentication using JWT.</p> <p>:param scope: ASGI request scope :return: Validated token data or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>async def authenticate(self, scope) -&gt; AuthData | None:\n    \"\"\"\n    Performs authentication using JWT.\n\n    :param scope: ASGI request scope\n    :return: Validated token data or None\n    \"\"\"\n\n    token_data = get_access_token(scope)\n    if token_data is None:\n        return self._callback()\n\n    validated_token = await self.validate_token(token_data[1])\n    if validated_token is None:\n        return self._callback()\n\n    validated_data = dict(validated_token)\n\n    auth = AuthData(\n        identifier=validated_data.pop(\"sub\"),\n        scope=validated_data.get(\"scope\", None),\n        extra=validated_data,\n    )\n\n    return auth\n</code></pre>"},{"location":"reference/auth/backend/#webtool.auth.backend.get_access_token","title":"get_access_token","text":"<pre><code>get_access_token(scope)\n</code></pre> <p>Extracts JWT from request scope.</p> <p>:param scope: ASGI request scope :return: (scheme, token) tuple or None</p> Source code in <code>webtool/auth/backend.py</code> <pre><code>def get_access_token(scope):\n    \"\"\"\n    Extracts JWT from request scope.\n\n    :param scope: ASGI request scope\n    :return: (scheme, token) tuple or None\n    \"\"\"\n\n    headers = scope.get(\"headers\")\n    if headers is None:\n        return None\n\n    authorization_value = _get_header_value(headers, \"authorization\")\n    if authorization_value is None:\n        return None\n\n    scheme, param = _get_authorization_scheme_param(authorization_value)\n    if scheme.lower() != \"bearer\" or not param:\n        return None\n\n    return scheme, param\n</code></pre>"},{"location":"reference/auth/manager/","title":"Auth - manager","text":"<p>This module provides functionality for handling JSON Web Tokens (JWT) for authentication and authorization. It defines the structure and methods required to encode and decode JWTs, as well as manage the claims associated with the tokens.</p>"},{"location":"reference/auth/manager/#webtool.auth.manager.BaseJWTManager","title":"BaseJWTManager","text":"<p>               Bases: <code>ABC</code></p> <p>Abstract base class for managing JSON Web Tokens (JWT). This class defines the interface for encoding and decoding JWT (RFC7519).</p> Info <p>\ub300\ubd80\ubd84\uc758 \uacbd\uc6b0 \ud574\ub2f9 \ud074\ub798\uc2a4\uc758 \ud558\uc704 \uad6c\ud604\uccb4\ub97c \uc9c1\uc811 \uc0ac\uc6a9\ud560 \ud544\uc694\ub294 \uac70\uc758 \uc5c6\uc2b5\ub2c8\ub2e4.</p>"},{"location":"reference/auth/manager/#webtool.auth.manager.BaseJWTManager.encode","title":"encode  <code>abstractmethod</code>","text":"<pre><code>encode(claims, secret_key, algorithm)\n</code></pre> <p>Encodes the specified claims into a JSON Web Token (JWT).</p> PARAMETER DESCRIPTION <code>claims</code> <p>A dictionary containing the claims to be included in the JWT.</p> <p> TYPE: <code>dict</code> </p> <code>secret_key</code> <p>The secret key used to sign the JWT.</p> <p> TYPE: <code>str | bytes</code> </p> <code>algorithm</code> <p>The signing algorithm to be used for the JWT.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A string representation of the encoded JWT.</p> <p> TYPE: <code>str</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If this method is not implemented in a subclass.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>@abstractmethod\ndef encode(\n    self,\n    claims: dict,\n    secret_key: str | bytes,\n    algorithm: str,\n) -&gt; str:\n    \"\"\"\n    Encodes the specified claims into a JSON Web Token (JWT).\n\n    Parameters:\n        claims: A dictionary containing the claims to be included in the JWT.\n        secret_key: The secret key used to sign the JWT.\n        algorithm: The signing algorithm to be used for the JWT.\n\n    Returns:\n        str: A string representation of the encoded JWT.\n\n    Raises:\n         NotImplementedError: If this method is not implemented in a subclass.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/auth/manager/#webtool.auth.manager.BaseJWTManager.decode","title":"decode  <code>abstractmethod</code>","text":"<pre><code>decode(token, secret_key, algorithm, at_hash=None)\n</code></pre> <p>Decodes a JSON Web Token (JWT) and validates its claims.</p> PARAMETER DESCRIPTION <code>token</code> <p>The JWT string to be decoded.</p> <p> TYPE: <code>str</code> </p> <code>secret_key</code> <p>The secret key used to validate the JWT signature.</p> <p> TYPE: <code>str | bytes</code> </p> <code>algorithm</code> <p>The signing algorithm used to verify the JWT,</p> <p> TYPE: <code>str</code> </p> <code>at_hash</code> <p>Optional parameter for additional handling of access tokens.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dicy</code> <p>A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.</p> <p> TYPE: <code>dict | None</code> </p> RAISES DESCRIPTION <code>NotImplementedError</code> <p>If this method is not implemented in a subclass.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>@abstractmethod\ndef decode(\n    self,\n    token: str,\n    secret_key: str | bytes,\n    algorithm: str,\n    at_hash: Optional[str] = None,\n) -&gt; dict | None:\n    \"\"\"\n    Decodes a JSON Web Token (JWT) and validates its claims.\n\n    Parameters:\n        token: The JWT string to be decoded.\n        secret_key: The secret key used to validate the JWT signature.\n        algorithm: The signing algorithm used to verify the JWT,\n        at_hash: Optional parameter for additional handling of access tokens.\n\n    Returns:\n        dicy: A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.\n\n    Raises:\n         NotImplementedError: If this method is not implemented in a subclass.\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/auth/manager/#webtool.auth.manager.JWTManager","title":"JWTManager","text":"<pre><code>JWTManager()\n</code></pre> <p>               Bases: <code>BaseJWTManager</code></p> <p>JWT manager for encoding and decoding JSON Web Tokens.</p> Source code in <code>webtool/auth/manager.py</code> <pre><code>def __init__(self):\n    self.jwt = jwt.PyJWT(self._get_default_options())\n</code></pre>"},{"location":"reference/auth/manager/#webtool.auth.manager.JWTManager.jwt","title":"jwt  <code>instance-attribute</code>","text":"<pre><code>jwt = PyJWT(_get_default_options())\n</code></pre>"},{"location":"reference/auth/manager/#webtool.auth.manager.JWTManager.encode","title":"encode","text":"<pre><code>encode(claims, secret_key, algorithm)\n</code></pre> <p>Encodes the specified claims into a JSON Web Token (JWT) with a specified expiration time.</p> PARAMETER DESCRIPTION <code>claims</code> <p>A dictionary containing the claims to be included in the JWT.</p> <p> TYPE: <code>dict</code> </p> <code>secret_key</code> <p>The secret key used to sign the JWT.</p> <p> TYPE: <code>str | bytes</code> </p> <code>algorithm</code> <p>The signing algorithm to use for the JWT, defaults to 'ES384'.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>Json Web Token (JWT).</p> <p> TYPE: <code>str</code> </p> Source code in <code>webtool/auth/manager.py</code> <pre><code>def encode(\n    self,\n    claims: dict,\n    secret_key: str | bytes,\n    algorithm: str,\n) -&gt; str:\n    \"\"\"\n    Encodes the specified claims into a JSON Web Token (JWT) with a specified expiration time.\n\n    Parameters:\n        claims: A dictionary containing the claims to be included in the JWT.\n        secret_key: The secret key used to sign the JWT.\n        algorithm: The signing algorithm to use for the JWT, defaults to 'ES384'.\n\n    Returns:\n        str: Json Web Token (JWT).\n    \"\"\"\n\n    return self.jwt.encode(claims, secret_key, algorithm)\n</code></pre>"},{"location":"reference/auth/manager/#webtool.auth.manager.JWTManager.decode","title":"decode","text":"<pre><code>decode(\n    token,\n    secret_key,\n    algorithm,\n    at_hash=None,\n    raise_error=False,\n)\n</code></pre> <p>Decodes a JSON Web Token (JWT) and returns the claims if valid.</p> PARAMETER DESCRIPTION <code>token</code> <p>The JWT string to be decoded.</p> <p> TYPE: <code>str</code> </p> <code>secret_key</code> <p>The secret key used to validate the JWT signature.</p> <p> TYPE: <code>str | bytes</code> </p> <code>algorithm</code> <p>The signing algorithm used for verification JWT, defaults to 'ES384'.</p> <p> TYPE: <code>str</code> </p> <code>at_hash</code> <p>Optional parameter for additional handling of access tokens.</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>raise_error</code> <p>Optional parameter for additional handling of error messages.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.</p> <p> TYPE: <code>dict | None</code> </p> Source code in <code>webtool/auth/manager.py</code> <pre><code>def decode(\n    self,\n    token: str,\n    secret_key: str | bytes,\n    algorithm: str,\n    at_hash: Optional[str] = None,\n    raise_error: bool = False,\n) -&gt; dict | None:\n    \"\"\"\n    Decodes a JSON Web Token (JWT) and returns the claims if valid.\n\n    Parameters:\n        token: The JWT string to be decoded.\n        secret_key: The secret key used to validate the JWT signature.\n        algorithm: The signing algorithm used for verification JWT, defaults to 'ES384'.\n        at_hash: Optional parameter for additional handling of access tokens.\n        raise_error: Optional parameter for additional handling of error messages.\n\n    Returns:\n        dict: A dictionary containing the claims if the token is valid, or None if the token is invalid or expired.\n    \"\"\"\n\n    try:\n        res = self.jwt.decode(token, secret_key, algorithms=[algorithm])\n\n        if at_hash and res.get(\"at_hash\") != at_hash:\n            raise ValueError(\"Invalid token\")\n\n        return res\n\n    except jwt.InvalidTokenError as e:\n        if raise_error:\n            raise e\n        else:\n            return None\n    except ValueError as e:\n        if raise_error:\n            raise e\n        else:\n            return None\n</code></pre>"},{"location":"reference/auth/service/","title":"Auth - service","text":""},{"location":"reference/auth/service/#webtool.auth.service.JWTService","title":"JWTService","text":"<pre><code>JWTService(\n    cache,\n    secret_key=\"\",\n    access_token_expire_time=3600,\n    refresh_token_expire_time=604800,\n    jwt_manager=None,\n    algorithm=None,\n)\n</code></pre> <p>               Bases: <code>BaseJWTService[PayloadType]</code>, <code>PayloadFactory</code>, <code>Generic[PayloadType]</code></p> <p>generate access token, refresh token</p> Info <p>Most cases, the <code>algorithm</code> parameter is automatically determined based on the <code>secret_key</code>, so there is no need to specify the <code>algorithm</code>. If using an asymmetric encryption key, providing the <code>secret_key</code> will automatically use the correct public key. The <code>secret_key</code> can be generated using the <code>webtools.utils</code> package.</p> Source code in <code>webtool/auth/service.py</code> <pre><code>def __init__(\n    self,\n    cache: \"BaseCache\",\n    secret_key: str | bytes = \"\",\n    access_token_expire_time: int = 3600,\n    refresh_token_expire_time: int = 604800,\n    jwt_manager: BaseJWTManager | None = None,\n    algorithm: str | None = None,\n):\n    self._cache = cache\n    self._secret_key = secret_key\n    self._jwt_manager = jwt_manager or JWTManager()\n    self._json_encoder = ORJSONEncoder()\n    self._json_decoder = ORJSONDecoder()\n    self.algorithm = algorithm\n    self.access_token_expire_time = access_token_expire_time\n    self.refresh_token_expire_time = refresh_token_expire_time\n\n    self._private_key = None\n    self._public_key = None\n\n    key_object = load_key(secret_key)\n\n    if len(key_object) == 3:\n        self._private_key, self._public_key, key_algorithm = key_object\n    else:\n        key_algorithm = key_object[-1]\n\n    self._verify_key_algorithm(key_algorithm)\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.algorithm","title":"algorithm  <code>instance-attribute</code>","text":"<pre><code>algorithm = algorithm\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.access_token_expire_time","title":"access_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>access_token_expire_time = access_token_expire_time\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.refresh_token_expire_time","title":"refresh_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>refresh_token_expire_time = refresh_token_expire_time\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.create_token","title":"create_token  <code>async</code>","text":"<pre><code>create_token(data)\n</code></pre> <p>Create Access and Refresh Tokens.</p> PARAMETER DESCRIPTION <code>data</code> <p>must include 'sub' field.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Access, Refresh Token.</p> <p> TYPE: <code>tuple[str, str]</code> </p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def create_token(self, data: dict) -&gt; tuple[str, str]:\n    \"\"\"\n    Create Access and Refresh Tokens.\n\n    Parameters:\n        data: must include 'sub' field.\n\n    Returns:\n        tuple: Access, Refresh Token.\n    \"\"\"\n    self._validate_sub(data)\n\n    access_data = self._create_metadata(data, self.access_token_expire_time)\n    refresh_data = self._create_metadata(data, self.refresh_token_expire_time)\n\n    access_token = self._create_token(access_data)\n    refresh_token = self._create_token(refresh_data)\n    await self._save_refresh_data(access_data, refresh_data)\n\n    return access_token, refresh_token\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.validate_access_token","title":"validate_access_token  <code>async</code>","text":"<pre><code>validate_access_token(access_token, validate_exp=True)\n</code></pre> <p>Validate Access Token.</p> PARAMETER DESCRIPTION <code>access_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> <code>validate_exp</code> <p>Whether to validate expiration or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[PayloadType]</code> <p>Optional[PayloadType]: Access Token Data</p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_access_token(self, access_token: str, validate_exp: bool = True) -&gt; Optional[PayloadType]:\n    \"\"\"\n    Validate Access Token.\n\n    Parameters:\n        access_token: Access Token.\n        validate_exp: Whether to validate expiration or not.\n\n    Returns:\n        Optional[PayloadType]: Access Token Data\n    \"\"\"\n    access_data = self._decode_token(access_token)\n\n    if validate_exp and not self._validate_exp(access_data):\n        return None\n\n    access_jti = self._get_jti(access_data)\n    key = f\"{JWTService._CACHE_INVALIDATE_PREFIX}{access_jti}\"\n\n    if await self._cache.get(key):\n        return None\n\n    return access_data\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.validate_refresh_token","title":"validate_refresh_token  <code>async</code>","text":"<pre><code>validate_refresh_token(refresh_token, validate_exp=True)\n</code></pre> <p>Validate Refresh Token.</p> PARAMETER DESCRIPTION <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> <code>validate_exp</code> <p>Whether to validate expiration or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[PayloadType]</code> <p>Optional[PayloadType]: Refresh Token Data</p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_refresh_token(self, refresh_token: str, validate_exp: bool = True) -&gt; Optional[PayloadType]:\n    \"\"\"\n    Validate Refresh Token.\n\n    Parameters:\n        refresh_token: Access Token.\n        validate_exp: Whether to validate expiration or not.\n\n    Returns:\n        Optional[PayloadType]: Refresh Token Data\n    \"\"\"\n    refresh_data = self._decode_token(refresh_token)\n\n    if validate_exp and not self._validate_exp(refresh_data):\n        return None\n\n    cached_refresh_data = await self._read_refresh_data(refresh_data)\n    if not cached_refresh_data:\n        return None\n\n    refresh_data[\"extra\"] |= cached_refresh_data\n    return refresh_data\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.invalidate_token","title":"invalidate_token  <code>async</code>","text":"<pre><code>invalidate_token(refresh_token)\n</code></pre> <p>Invalidates the Refresh token and the Access token issued with it .</p> PARAMETER DESCRIPTION <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Returns <code>true</code> on success.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def invalidate_token(self, refresh_token: str) -&gt; bool:\n    \"\"\"\n    Invalidates the Refresh token and the Access token issued with it .\n\n    Parameters:\n        refresh_token: Access Token.\n\n    Returns:\n        bool: Returns `true` on success.\n    \"\"\"\n    refresh_data = await self.validate_refresh_token(refresh_token)\n\n    if not refresh_data:\n        return False\n\n    await self._invalidate_token_data(refresh_data)\n    return True\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.JWTService.update_token","title":"update_token  <code>async</code>","text":"<pre><code>update_token(data, refresh_token)\n</code></pre> <p>Invalidates the Refresh token and the Access token issued with it and issue New Access and Refresh Tokens.</p> PARAMETER DESCRIPTION <code>data</code> <p>Token data.</p> <p> TYPE: <code>dict</code> </p> <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Access, Refresh Token.</p> <p> TYPE: <code>tuple[str, str] | None</code> </p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def update_token(self, data: dict, refresh_token: str) -&gt; tuple[str, str] | None:\n    \"\"\"\n    Invalidates the Refresh token and the Access token issued with it and issue New Access and Refresh Tokens.\n\n    Parameters:\n        data: Token data.\n        refresh_token: Access Token.\n\n    Returns:\n        tuple: Access, Refresh Token.\n    \"\"\"\n    refresh_data = await self.invalidate_token(refresh_token)\n\n    if not refresh_data:\n        return None\n\n    new_access_token, new_refresh_token = await self.create_token(data)\n\n    return new_access_token, new_refresh_token\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService","title":"RedisJWTService","text":"<pre><code>RedisJWTService(\n    cache,\n    secret_key=\"\",\n    access_token_expire_time=3600,\n    refresh_token_expire_time=604800,\n    jwt_manager=None,\n    algorithm=None,\n)\n</code></pre> <p>               Bases: <code>JWTService</code>, <code>Generic[PayloadType]</code></p> <p>generate access token, refresh token</p> Info <p>Most cases, the <code>algorithm</code> parameter is automatically determined based on the <code>secret_key</code>, so there is no need to specify the <code>algorithm</code>. If using an asymmetric encryption key, providing the <code>secret_key</code> will automatically use the correct public key. The <code>secret_key</code> can be generated using the <code>webtools.utils</code> package.</p> Source code in <code>webtool/auth/service.py</code> <pre><code>def __init__(\n    self,\n    cache: \"RedisCache\",\n    secret_key: str | bytes = \"\",\n    access_token_expire_time: int = 3600,\n    refresh_token_expire_time: int = 604800,\n    jwt_manager: BaseJWTManager | None = None,\n    algorithm: str | None = None,\n):\n    super().__init__(cache, secret_key, access_token_expire_time, refresh_token_expire_time, jwt_manager, algorithm)\n    self._save_script = self._cache.cache.register_script(RedisJWTService._LUA_SAVE_TOKEN_SCRIPT)\n    self._invalidate_script = self._cache.cache.register_script(RedisJWTService._LUA_INVALIDATE_TOKEN_SCRIPT)\n    self._search_script = self._cache.cache.register_script(RedisJWTService._LUA_SEARCH_TOKEN_SCRIPT)\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.algorithm","title":"algorithm  <code>instance-attribute</code>","text":"<pre><code>algorithm = algorithm\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.access_token_expire_time","title":"access_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>access_token_expire_time = access_token_expire_time\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.refresh_token_expire_time","title":"refresh_token_expire_time  <code>instance-attribute</code>","text":"<pre><code>refresh_token_expire_time = refresh_token_expire_time\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.create_token","title":"create_token  <code>async</code>","text":"<pre><code>create_token(data)\n</code></pre> <p>Create Access and Refresh Tokens.</p> PARAMETER DESCRIPTION <code>data</code> <p>must include 'sub' field.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Access, Refresh Token.</p> <p> TYPE: <code>tuple[str, str]</code> </p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def create_token(self, data: dict) -&gt; tuple[str, str]:\n    \"\"\"\n    Create Access and Refresh Tokens.\n\n    Parameters:\n        data: must include 'sub' field.\n\n    Returns:\n        tuple: Access, Refresh Token.\n    \"\"\"\n    self._validate_sub(data)\n\n    access_data = self._create_metadata(data, self.access_token_expire_time)\n    refresh_data = self._create_metadata(data, self.refresh_token_expire_time)\n\n    access_token = self._create_token(access_data)\n    refresh_token = self._create_token(refresh_data)\n    await self._save_refresh_data(access_data, refresh_data)\n\n    return access_token, refresh_token\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.validate_access_token","title":"validate_access_token  <code>async</code>","text":"<pre><code>validate_access_token(access_token, validate_exp=True)\n</code></pre> <p>Validate Access Token.</p> PARAMETER DESCRIPTION <code>access_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> <code>validate_exp</code> <p>Whether to validate expiration or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[PayloadType]</code> <p>Optional[PayloadType]: Access Token Data</p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_access_token(self, access_token: str, validate_exp: bool = True) -&gt; Optional[PayloadType]:\n    \"\"\"\n    Validate Access Token.\n\n    Parameters:\n        access_token: Access Token.\n        validate_exp: Whether to validate expiration or not.\n\n    Returns:\n        Optional[PayloadType]: Access Token Data\n    \"\"\"\n    access_data = self._decode_token(access_token)\n\n    if validate_exp and not self._validate_exp(access_data):\n        return None\n\n    access_jti = self._get_jti(access_data)\n    key = f\"{JWTService._CACHE_INVALIDATE_PREFIX}{access_jti}\"\n\n    if await self._cache.get(key):\n        return None\n\n    return access_data\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.validate_refresh_token","title":"validate_refresh_token  <code>async</code>","text":"<pre><code>validate_refresh_token(refresh_token, validate_exp=True)\n</code></pre> <p>Validate Refresh Token.</p> PARAMETER DESCRIPTION <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> <code>validate_exp</code> <p>Whether to validate expiration or not.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> RETURNS DESCRIPTION <code>Optional[PayloadType]</code> <p>Optional[PayloadType]: Refresh Token Data</p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def validate_refresh_token(self, refresh_token: str, validate_exp: bool = True) -&gt; Optional[PayloadType]:\n    \"\"\"\n    Validate Refresh Token.\n\n    Parameters:\n        refresh_token: Access Token.\n        validate_exp: Whether to validate expiration or not.\n\n    Returns:\n        Optional[PayloadType]: Refresh Token Data\n    \"\"\"\n    refresh_data = self._decode_token(refresh_token)\n\n    if validate_exp and not self._validate_exp(refresh_data):\n        return None\n\n    cached_refresh_data = await self._read_refresh_data(refresh_data)\n    if not cached_refresh_data:\n        return None\n\n    refresh_data[\"extra\"] |= cached_refresh_data\n    return refresh_data\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.update_token","title":"update_token  <code>async</code>","text":"<pre><code>update_token(data, refresh_token)\n</code></pre> <p>Invalidates the Refresh token and the Access token issued with it and issue New Access and Refresh Tokens.</p> PARAMETER DESCRIPTION <code>data</code> <p>Token data.</p> <p> TYPE: <code>dict</code> </p> <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>tuple</code> <p>Access, Refresh Token.</p> <p> TYPE: <code>tuple[str, str] | None</code> </p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def update_token(self, data: dict, refresh_token: str) -&gt; tuple[str, str] | None:\n    \"\"\"\n    Invalidates the Refresh token and the Access token issued with it and issue New Access and Refresh Tokens.\n\n    Parameters:\n        data: Token data.\n        refresh_token: Access Token.\n\n    Returns:\n        tuple: Access, Refresh Token.\n    \"\"\"\n    refresh_data = await self.invalidate_token(refresh_token)\n\n    if not refresh_data:\n        return None\n\n    new_access_token, new_refresh_token = await self.create_token(data)\n\n    return new_access_token, new_refresh_token\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.invalidate_token","title":"invalidate_token  <code>async</code>","text":"<pre><code>invalidate_token(\n    refresh_token, refresh_jti_to_invalidate=None\n)\n</code></pre> <p>Invalidates the Refresh token and the Access token issued with it .</p> PARAMETER DESCRIPTION <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> <code>refresh_jti_to_invalidate</code> <p>Refresh Token JTI to invalidate can be found using search_token.</p> <p> TYPE: <code>str | bytes | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>Returns <code>true</code> on success.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def invalidate_token(\n    self,\n    refresh_token: str,\n    refresh_jti_to_invalidate: str | bytes | None = None,\n) -&gt; bool:\n    \"\"\"\n    Invalidates the Refresh token and the Access token issued with it .\n\n    Parameters:\n        refresh_token: Access Token.\n        refresh_jti_to_invalidate: Refresh Token JTI to invalidate can be found using search_token.\n\n    Returns:\n        bool: Returns `true` on success.\n    \"\"\"\n    refresh_data = await self.validate_refresh_token(refresh_token)\n\n    if not refresh_data:\n        return False\n\n    return await self._invalidate_token_data(refresh_data, refresh_jti_to_invalidate)\n</code></pre>"},{"location":"reference/auth/service/#webtool.auth.service.RedisJWTService.search_token","title":"search_token  <code>async</code>","text":"<pre><code>search_token(refresh_token)\n</code></pre> <p>Returns the JTI of the refresh token issued with the token\u2019s sub claim</p> PARAMETER DESCRIPTION <code>refresh_token</code> <p>Access Token.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>list[bytes]</code> <p>list[bytes]: Returns a list containing JTIs on success.</p> Source code in <code>webtool/auth/service.py</code> <pre><code>async def search_token(self, refresh_token: str) -&gt; list[bytes]:\n    \"\"\"\n    Returns the JTI of the refresh token issued with the token\u2019s sub claim\n\n    Parameters:\n        refresh_token: Access Token.\n\n    Returns:\n        list[bytes]: Returns a list containing JTIs on success.\n    \"\"\"\n    refresh_data = self._decode_token(refresh_token)\n    refresh_json = self._json_encoder.encode(refresh_data)\n\n    return await self._search_script(\n        keys=[refresh_json],\n        args=[\n            time.time(),\n            self.refresh_token_expire_time,\n        ],\n    )\n</code></pre>"},{"location":"reference/cache/client/","title":"Cache - client","text":""},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache","title":"InMemoryCache","text":"<pre><code>InMemoryCache()\n</code></pre> <p>               Bases: <code>BaseCache</code></p> <p>Implementation of a InMemory client. DO NOT USE IN PRODUCTION.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>def __init__(self):\n    self.cache: dict = {}\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache = {}\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache.lock","title":"lock","text":"<pre><code>lock(\n    key,\n    ttl_ms=100,\n    blocking=True,\n    blocking_timeout=DEFAULT_CAP,\n    blocking_sleep=DEFAULT_BASE,\n)\n</code></pre> <p>Sets a key-value pair in a lock mechanism.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to be locked.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <code>ttl_ms</code> <p>The time-to-live for the lock in milliseconds.</p> <p> TYPE: <code>Union[int, timedelta, None]</code> DEFAULT: <code>100</code> </p> <code>blocking</code> <p>If True, the method will block until the lock is acquired.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>blocking_timeout</code> <p>The maximum time in seconds to block while waiting for the lock to be acquired.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_CAP</code> </p> <code>blocking_sleep</code> <p>The time in seconds to wait between attempts to acquire the lock when blocking.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_BASE</code> </p> RETURNS DESCRIPTION <code>AsyncInMemoryLock</code> <p>The Lock object representing the acquired lock.</p> <p> TYPE: <code>AsyncInMemoryLock</code> </p> Source code in <code>webtool/cache/client.py</code> <pre><code>def lock(\n    self,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None] = 100,\n    blocking: bool = True,\n    blocking_timeout: float = DEFAULT_CAP,\n    blocking_sleep: float = DEFAULT_BASE,\n) -&gt; AsyncInMemoryLock:\n    \"\"\"\n    Sets a key-value pair in a lock mechanism.\n\n    Parameters:\n        key: The key to be locked.\n        ttl_ms: The time-to-live for the lock in milliseconds.\n        blocking: If True, the method will block until the lock is acquired.\n        blocking_timeout: The maximum time in seconds to block while waiting for the lock to be acquired.\n        blocking_sleep: The time in seconds to wait between attempts to acquire the lock when blocking.\n\n    Returns:\n        AsyncInMemoryLock: The Lock object representing the acquired lock.\n    \"\"\"\n    return AsyncInMemoryLock(self, key, ttl_ms, blocking, blocking_timeout, blocking_sleep)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ex=None, exat=None, nx=False)\n</code></pre> <p>Sets a key-value pair.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for the data to be set.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <code>value</code> <p>The value associated with the key.</p> <p> TYPE: <code>Union[bytes, memoryview, str, int, float]</code> </p> <code>ex</code> <p>Expiration time for the key, in seconds or as a timedelta.</p> <p> TYPE: <code>Union[int, timedelta, None]</code> DEFAULT: <code>None</code> </p> <code>exat</code> <p>Expiration time as an absolute timestamp.</p> <p> TYPE: <code>Union[int, datetime, None]</code> DEFAULT: <code>None</code> </p> <code>nx</code> <p>if set to True, set the value at key to value only if it does not exist.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>return of set.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def set(\n    self,\n    key: Union[bytes, str, memoryview],\n    value: Union[bytes, memoryview, str, int, float],\n    ex: Union[int, timedelta, None] = None,\n    exat: Union[int, datetime, None] = None,\n    nx: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Sets a key-value pair.\n\n    Parameters:\n        key: The key for the data to be set.\n        value: The value associated with the key.\n        ex: Expiration time for the key, in seconds or as a timedelta.\n        exat: Expiration time as an absolute timestamp.\n        nx: if set to True, set the value at key to value only if it does not exist.\n\n    Returns:\n        Any: return of set.\n    \"\"\"\n\n    await self._expire()\n    if nx and self.cache.get(key):\n        return None\n\n    if ex:\n        now = asyncio.get_running_loop().time()\n        if isinstance(ex, (float, int)):\n            exp = now + ex\n        else:\n            exp = now + ex.total_seconds()\n    else:\n        if isinstance(exat, int):\n            exp = exat\n        elif isinstance(exat, datetime):\n            exp = exat.timestamp()\n        else:\n            exp = float(\"inf\")\n\n    self.cache[key] = (value, exp)\n    return self.cache[key]\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>Gets a key-value pair.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for the data to be set.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <p>Returns:     Any: return of get.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def get(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    \"\"\"\n    Gets a key-value pair.\n\n    Parameters:\n        key: The key for the data to be set.\n    Returns:\n        Any: return of get.\n    \"\"\"\n\n    await self._expire()\n\n    val = self.cache.get(key)\n    if val:\n        return val[0]\n    return None\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Deletes a key-value pair.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for the data to be set.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <p>Returns:     None</p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def delete(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    \"\"\"\n    Deletes a key-value pair.\n\n    Parameters:\n        key: The key for the data to be set.\n    Returns:\n        None\n    \"\"\"\n\n    await self._expire()\n\n    return self.cache.pop(key)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.InMemoryCache.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Closes the Cache client.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"\n    Closes the Cache client.\n    \"\"\"\n\n    self.cache.clear()\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache","title":"RedisCache","text":"<pre><code>RedisCache(\n    redis_url=None,\n    connection_pool=None,\n    logger=None,\n    config=None,\n)\n</code></pre> <p>               Bases: <code>BaseCache</code></p> <p>Implementation of a Redis client with failover capabilities.</p> <p>Initializes the Redis client.</p> PARAMETER DESCRIPTION <code>redis_url</code> <p>Redis data source name for connection.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>connection_pool</code> <p>An existing connection pool to use.</p> <p> TYPE: <code>Optional[ConnectionPool]</code> DEFAULT: <code>None</code> </p> Source code in <code>webtool/cache/client.py</code> <pre><code>def __init__(\n    self,\n    redis_url: str = None,\n    connection_pool: Optional[ConnectionPool] = None,\n    logger: logging.Logger = None,\n    config: RedisConfig | None = None,\n):\n    \"\"\"\n    Initializes the Redis client.\n\n    Parameters:\n        redis_url: Redis data source name for connection.\n        connection_pool: An existing connection pool to use.\n    \"\"\"\n\n    self.logger = logger or logging.getLogger(__name__)\n    self.config = config or RedisConfig()\n\n    if connection_pool:\n        self.connection_pool = connection_pool\n    elif redis_url:\n        kwargs = self.config.to_dict()\n        kwargs.update(\n            {\n                \"retry\": deepcopy(self.config.retry),\n            }\n        )\n        self.connection_pool = ConnectionPool.from_url(redis_url, **kwargs)\n    else:\n        raise TypeError(\"RedisClient must be provided with either redis_dsn or connection_pool\")\n\n    self.cache: Redis = Redis.from_pool(self.connection_pool)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.logger","title":"logger  <code>instance-attribute</code>","text":"<pre><code>logger = logger or getLogger(__name__)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.config","title":"config  <code>instance-attribute</code>","text":"<pre><code>config = config or RedisConfig()\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.connection_pool","title":"connection_pool  <code>instance-attribute</code>","text":"<pre><code>connection_pool = connection_pool\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache = from_pool(connection_pool)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.lock","title":"lock","text":"<pre><code>lock(\n    key,\n    ttl_ms=100,\n    blocking=True,\n    blocking_timeout=DEFAULT_CAP,\n    blocking_sleep=DEFAULT_BASE,\n)\n</code></pre> <p>Sets a key-value pair in a lock mechanism.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to be locked.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <code>ttl_ms</code> <p>The time-to-live for the lock in milliseconds.</p> <p> TYPE: <code>Union[int, timedelta, None]</code> DEFAULT: <code>100</code> </p> <code>blocking</code> <p>If True, the method will block until the lock is acquired.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>blocking_timeout</code> <p>The maximum time in seconds to block while waiting for the lock to be acquired.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_CAP</code> </p> <code>blocking_sleep</code> <p>The time in seconds to wait between attempts to acquire the lock when blocking.</p> <p> TYPE: <code>float</code> DEFAULT: <code>DEFAULT_BASE</code> </p> RETURNS DESCRIPTION <code>AsyncRedisLock</code> <p>The Lock object representing the acquired lock.</p> <p> TYPE: <code>AsyncRedisLock</code> </p> Source code in <code>webtool/cache/client.py</code> <pre><code>def lock(\n    self,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None] = 100,\n    blocking: bool = True,\n    blocking_timeout: float = DEFAULT_CAP,\n    blocking_sleep: float = DEFAULT_BASE,\n) -&gt; AsyncRedisLock:\n    \"\"\"\n    Sets a key-value pair in a lock mechanism.\n\n    Parameters:\n        key: The key to be locked.\n        ttl_ms: The time-to-live for the lock in milliseconds.\n        blocking: If True, the method will block until the lock is acquired.\n        blocking_timeout: The maximum time in seconds to block while waiting for the lock to be acquired.\n        blocking_sleep: The time in seconds to wait between attempts to acquire the lock when blocking.\n\n    Returns:\n        AsyncRedisLock: The Lock object representing the acquired lock.\n    \"\"\"\n    return AsyncRedisLock(self, key, ttl_ms, blocking, blocking_timeout, blocking_sleep)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.set","title":"set  <code>async</code>","text":"<pre><code>set(key, value, ex=None, exat=None, nx=False)\n</code></pre> <p>Sets a key-value pair.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for the data to be set.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <code>value</code> <p>The value associated with the key.</p> <p> TYPE: <code>Union[bytes, memoryview, str, int, float]</code> </p> <code>ex</code> <p>Expiration time for the key, in seconds or as a timedelta.</p> <p> TYPE: <code>Union[int, timedelta, None]</code> DEFAULT: <code>None</code> </p> <code>exat</code> <p>Expiration time as an absolute timestamp.</p> <p> TYPE: <code>Union[int, datetime, None]</code> DEFAULT: <code>None</code> </p> <code>nx</code> <p>if set to True, set the value at key to value only if it does not exist.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>Any</code> <p>return of set.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def set(\n    self,\n    key: Union[bytes, str, memoryview],\n    value: Union[bytes, memoryview, str, int, float],\n    ex: Union[int, timedelta, None] = None,\n    exat: Union[int, datetime, None] = None,\n    nx: bool = False,\n) -&gt; Any:\n    \"\"\"\n    Sets a key-value pair.\n\n    Parameters:\n        key: The key for the data to be set.\n        value: The value associated with the key.\n        ex: Expiration time for the key, in seconds or as a timedelta.\n        exat: Expiration time as an absolute timestamp.\n        nx: if set to True, set the value at key to value only if it does not exist.\n\n    Returns:\n        Any: return of set.\n    \"\"\"\n\n    return await self.cache.set(key, value, ex=ex, exat=exat, nx=nx)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.get","title":"get  <code>async</code>","text":"<pre><code>get(key)\n</code></pre> <p>Gets a key-value pair.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for the data to be set.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <p>Returns:     Any: return of get.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def get(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    \"\"\"\n    Gets a key-value pair.\n\n    Parameters:\n        key: The key for the data to be set.\n    Returns:\n        Any: return of get.\n    \"\"\"\n\n    return await self.cache.get(key)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key)\n</code></pre> <p>Deletes a key-value pair.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key for the data to be set.</p> <p> TYPE: <code>Union[bytes, str, memoryview]</code> </p> <p>Returns:     None</p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def delete(\n    self,\n    key: Union[bytes, str, memoryview],\n) -&gt; Any:\n    \"\"\"\n    Deletes a key-value pair.\n\n    Parameters:\n        key: The key for the data to be set.\n    Returns:\n        None\n    \"\"\"\n\n    return await self.cache.delete(key)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisCache.aclose","title":"aclose  <code>async</code>","text":"<pre><code>aclose()\n</code></pre> <p>Closes the Redis client connection and connection pool.</p> Source code in <code>webtool/cache/client.py</code> <pre><code>async def aclose(self) -&gt; None:\n    \"\"\"\n    Closes the Redis client connection and connection pool.\n    \"\"\"\n\n    self.logger.info(f\"Closing Redis client connection (id: {id(self)})\")\n\n    try:\n        await self.cache.aclose()\n    except AttributeError as e:\n        self.logger.warning(f\"Failed to close Redis connection: {e}\")\n\n    try:\n        await self.connection_pool.aclose()\n        await self.connection_pool.disconnect()\n    except AttributeError as e:\n        self.logger.warning(f\"Failed to close connection pool: {e}\")\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig","title":"RedisConfig  <code>dataclass</code>","text":"<pre><code>RedisConfig(\n    username=None,\n    password=None,\n    health_check_interval=0,\n    socket_timeout=0.5,\n    socket_connect_timeout=2.0,\n    socket_keepalive=True,\n    retry=Retry(default_backoff(), retries=3),\n    retry_on_error=lambda: [\n        BusyLoadingError,\n        ConnectionError,\n        RedisError,\n        OSError,\n    ](),\n    retry_on_timeout=True,\n    ssl=False,\n    max_connections=None,\n    protocol=3,\n)\n</code></pre> <p>Configuration settings for establishing a connection with a Redis server.</p> PARAMETER DESCRIPTION <code>username</code> <p>username</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>password</code> <p>password</p> <p> TYPE: <code>Optional[str]</code> DEFAULT: <code>None</code> </p> <code>health_check_interval</code> <p>Interval in seconds for performing health checks.</p> <p> TYPE: <code>int</code> DEFAULT: <code>0</code> </p> <code>socket_timeout</code> <p>Timeout in seconds for socket operations, including reads and writes.</p> <p> TYPE: <code>float</code> DEFAULT: <code>0.5</code> </p> <code>socket_connect_timeout</code> <p>Timeout in seconds for establishing a new connection to Redis.</p> <p> TYPE: <code>float</code> DEFAULT: <code>2.0</code> </p> <code>socket_keepalive</code> <p>Whether to enable TCP keepalive for the connection. Default is True.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>retry</code> <p>Retry policy for handling transient failures.</p> <p> TYPE: <code>Optional[Retry]</code> DEFAULT: <code>Retry(default_backoff(), retries=3)</code> </p> <code>retry_on_error</code> <p>A list of exception types that should trigger a retry.</p> <p> TYPE: <code>Optional[list[type[Exception]]]</code> DEFAULT: <code>lambda: [BusyLoadingError, ConnectionError, RedisError, OSError]()</code> </p> <code>retry_on_timeout</code> <p>Whether to retry operations when a timeout occurs.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>ssl</code> <p>Specifies if SSL should be used for the Redis connection.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> <code>protocol</code> <p>Redis protocol version to be used. Default is RESP3.</p> <p> TYPE: <code>Optional[int]</code> DEFAULT: <code>3</code> </p> METHOD DESCRIPTION <code>to_dict</code> <p>Converts the configuration fields to a dictionary.</p>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.username","title":"username  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>username = None\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.password","title":"password  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>password = None\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.health_check_interval","title":"health_check_interval  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>health_check_interval = 0\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.socket_timeout","title":"socket_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>socket_timeout = 0.5\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.socket_connect_timeout","title":"socket_connect_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>socket_connect_timeout = 2.0\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.socket_keepalive","title":"socket_keepalive  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>socket_keepalive = True\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.retry","title":"retry  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry = Retry(default_backoff(), retries=3)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.retry_on_error","title":"retry_on_error  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_on_error = field(\n    default_factory=lambda: [\n        BusyLoadingError,\n        ConnectionError,\n        RedisError,\n        OSError,\n    ]\n)\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.retry_on_timeout","title":"retry_on_timeout  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>retry_on_timeout = True\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.ssl","title":"ssl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ssl = False\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.max_connections","title":"max_connections  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>max_connections = None\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.protocol","title":"protocol  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>protocol = 3\n</code></pre>"},{"location":"reference/cache/client/#webtool.cache.client.RedisConfig.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> Source code in <code>webtool/cache/client.py</code> <pre><code>def to_dict(self) -&gt; dict[str, Any]:\n    return {k: v for k, v in self.__dict__.items() if v}\n</code></pre>"},{"location":"reference/cache/lock/","title":"Cache - lock","text":"<p>Info</p> <p>The Lock is used with the Cache Client. In most cases, there is no need to directly use the Lock object</p>"},{"location":"reference/cache/lock/#webtool.cache.lock.AsyncInMemoryLock","title":"AsyncInMemoryLock","text":"<pre><code>AsyncInMemoryLock(\n    client,\n    key,\n    ttl_ms,\n    blocking,\n    blocking_timeout,\n    blocking_sleep,\n)\n</code></pre> <p>               Bases: <code>BaseLock</code></p> Source code in <code>webtool/cache/lock.py</code> <pre><code>def __init__(\n    self,\n    client,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None],\n    blocking: bool,\n    blocking_timeout: float,\n    blocking_sleep: float,\n):\n    self._client = client\n    self._key = key\n    self._ttl = ttl_ms\n    self._blocking = blocking\n    self._blocking_timeout = blocking_timeout\n    self._blocking_sleep = blocking_sleep / 2\n</code></pre>"},{"location":"reference/cache/lock/#webtool.cache.lock.AsyncInMemoryLock.acquire","title":"acquire  <code>async</code>","text":"<pre><code>acquire()\n</code></pre> <p>if blocking is enabled, retry with Equal Jitter Backoff strategy</p> RETURNS DESCRIPTION <code>bool</code> <p>True when acquired lock, else False</p> <p> TYPE: <code>bool</code> </p> Source code in <code>webtool/cache/lock.py</code> <pre><code>async def acquire(self) -&gt; bool:\n    \"\"\"\n    if blocking is enabled, retry with Equal Jitter Backoff strategy\n\n    Returns:\n        bool: True when acquired lock, else False\n    \"\"\"\n    self._key = sha256(self._key)\n    start_time = asyncio.get_running_loop().time()\n\n    while True:\n        lock_acquired = await self._client.set(self._key, 1, ex=self._ttl / 1000, nx=True)\n        if lock_acquired:\n            return True\n\n        if not self._blocking:\n            return False\n\n        failed_time = asyncio.get_running_loop().time()\n        if failed_time - start_time &gt; self._blocking_timeout:\n            return False\n\n        delay = (1 + random.random()) * self._blocking_sleep\n        await asyncio.sleep(delay)\n</code></pre>"},{"location":"reference/cache/lock/#webtool.cache.lock.AsyncInMemoryLock.release","title":"release  <code>async</code>","text":"<pre><code>release()\n</code></pre> Source code in <code>webtool/cache/lock.py</code> <pre><code>async def release(self):\n    await self._client.delete(self._key)\n</code></pre>"},{"location":"reference/cache/lock/#webtool.cache.lock.AsyncRedisLock","title":"AsyncRedisLock","text":"<pre><code>AsyncRedisLock(\n    client,\n    key,\n    ttl_ms,\n    blocking,\n    blocking_timeout,\n    blocking_sleep,\n)\n</code></pre> <p>               Bases: <code>BaseLock</code></p> Source code in <code>webtool/cache/lock.py</code> <pre><code>def __init__(\n    self,\n    client,\n    key: Union[bytes, str, memoryview],\n    ttl_ms: Union[int, timedelta, None],\n    blocking: bool,\n    blocking_timeout: float,\n    blocking_sleep: float,\n):\n    self._client = client\n    self._key = key\n    self._ttl = ttl_ms\n    self._blocking = blocking\n    self._blocking_timeout = blocking_timeout\n    self._blocking_sleep = blocking_sleep / 2\n</code></pre>"},{"location":"reference/cache/lock/#webtool.cache.lock.AsyncRedisLock.acquire","title":"acquire  <code>async</code>","text":"<pre><code>acquire()\n</code></pre> <p>if blocking is enabled, retry with Equal Jitter Backoff strategy</p> RETURNS DESCRIPTION <code>bool</code> <p>True when acquired lock, else False</p> <p> TYPE: <code>bool</code> </p> Source code in <code>webtool/cache/lock.py</code> <pre><code>async def acquire(self) -&gt; bool:\n    \"\"\"\n    if blocking is enabled, retry with Equal Jitter Backoff strategy\n\n    Returns:\n        bool: True when acquired lock, else False\n    \"\"\"\n    self._key = sha256(self._key)\n    start_time = asyncio.get_running_loop().time()\n\n    while True:\n        lock_acquired = await self._client.cache.set(self._key, 1, px=self._ttl, nx=True)\n        if lock_acquired:\n            return True\n\n        if not self._blocking:\n            return False\n\n        failed_time = asyncio.get_running_loop().time()\n        if failed_time - start_time &gt; self._blocking_timeout:\n            return False\n\n        delay = (1 + random.random()) * self._blocking_sleep\n        await asyncio.sleep(delay)\n</code></pre>"},{"location":"reference/cache/lock/#webtool.cache.lock.AsyncRedisLock.release","title":"release  <code>async</code>","text":"<pre><code>release()\n</code></pre> Source code in <code>webtool/cache/lock.py</code> <pre><code>async def release(self):\n    await self._client.cache.delete(self._key)\n</code></pre>"},{"location":"reference/throttle/decorator/","title":"throttle - decorator","text":""},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.THROTTLE_RULE_ATTR_NAME","title":"THROTTLE_RULE_ATTR_NAME  <code>module-attribute</code>","text":"<pre><code>THROTTLE_RULE_ATTR_NAME = '_throttle_rules'\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule","title":"LimitRule","text":"<pre><code>LimitRule(\n    max_requests, interval, throttle_key, method, scopes\n)\n</code></pre> <p>Represents a single rate limiting rule.</p> <p>Contains the conditions and parameters for a rate limit: - Maximum requests allowed - Time interval - Unique identifier - HTTP methods (optional) - User scopes (optional)</p> <p>:param max_requests: Maximum number of requests allowed :param interval: Time interval in seconds :param throttle_key: Unique identifier for this rule :param method: List of HTTP methods this rule applies to :param scopes: List of user scopes this rule applies to</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def __init__(\n    self,\n    max_requests: int,\n    interval: int,\n    throttle_key: str,\n    method: Optional[list[str]],\n    scopes: Optional[list[str]],\n):\n    \"\"\"\n    :param max_requests: Maximum number of requests allowed\n    :param interval: Time interval in seconds\n    :param throttle_key: Unique identifier for this rule\n    :param method: List of HTTP methods this rule applies to\n    :param scopes: List of user scopes this rule applies to\n    \"\"\"\n\n    self.max_requests: int = max_requests\n    self.interval: int = interval\n    self.throttle_key: str = throttle_key\n    self.method: Optional[set[str]] = set(method)\n    self.scopes: Optional[set[str]] = set(scopes)\n    self.for_user: bool = \"user\" in scopes or (\"user\" in scopes) == (\"anno\" in scopes)\n    self.for_anno: bool = \"anno\" in scopes or (\"user\" in scopes) == (\"anno\" in scopes)\n\n    self.scopes.discard(\"user\")\n    self.scopes.discard(\"anno\")\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.max_requests","title":"max_requests  <code>instance-attribute</code>","text":"<pre><code>max_requests = max_requests\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.interval","title":"interval  <code>instance-attribute</code>","text":"<pre><code>interval = interval\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.throttle_key","title":"throttle_key  <code>instance-attribute</code>","text":"<pre><code>throttle_key = throttle_key\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.method","title":"method  <code>instance-attribute</code>","text":"<pre><code>method = set(method)\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.scopes","title":"scopes  <code>instance-attribute</code>","text":"<pre><code>scopes = set(scopes)\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.for_user","title":"for_user  <code>instance-attribute</code>","text":"<pre><code>for_user = (\n    \"user\" in scopes or \"user\" in scopes == \"anno\" in scopes\n)\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.for_anno","title":"for_anno  <code>instance-attribute</code>","text":"<pre><code>for_anno = (\n    \"anno\" in scopes or \"user\" in scopes == \"anno\" in scopes\n)\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRule.is_enabled","title":"is_enabled","text":"<pre><code>is_enabled(\n    scope,\n    anno_identifier=None,\n    user_identifier=None,\n    auth_scope=None,\n)\n</code></pre> <p>Checks if this rule should be applied based on request context.</p> <p>:param scope: ASGI request scope :param anno_identifier: Anonymous user identifier :param user_identifier: Authenticated user identifier (optional) :param auth_scope: List of user scopes this rule applies to :return: Boolean indicating if rule should be applied</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def is_enabled(\n    self,\n    scope,\n    anno_identifier: Any | None = None,\n    user_identifier: Any | None = None,\n    auth_scope: list[str] | None = None,\n):\n    \"\"\"\n    Checks if this rule should be applied based on request context.\n\n    :param scope: ASGI request scope\n    :param anno_identifier: Anonymous user identifier\n    :param user_identifier: Authenticated user identifier (optional)\n    :param auth_scope: List of user scopes this rule applies to\n    :return: Boolean indicating if rule should be applied\n    \"\"\"\n\n    if self.method and scope.get(\"method\") not in self.method:\n        return False\n\n    if not self.scopes or (auth_scope and set(auth_scope) &amp; self.scopes):\n        if user_identifier and self.for_user:\n            return True\n        elif anno_identifier and self.for_anno:\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager","title":"LimitRuleManager","text":"<pre><code>LimitRuleManager()\n</code></pre> <p>Container class for managing multiple rate limit rules. Allows adding and checking rules for specific requests.</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def __init__(self):\n    self.rules: set[LimitRule] = set()\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager.rules","title":"rules  <code>instance-attribute</code>","text":"<pre><code>rules = set()\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager.should_limit","title":"should_limit","text":"<pre><code>should_limit(\n    scopes,\n    anno_identifier=None,\n    user_identifier=None,\n    auth_scope=None,\n)\n</code></pre> <p>Determines which rules should be applied for a given request.</p> <p>:param scopes: ASGI request scope :param anno_identifier: Anonymous user identifier (optional) :param user_identifier: Authenticated user identifier (optional) :param auth_scope: List of user scopes this rule applies to :return: List of applicable rules</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def should_limit(\n    self,\n    scopes,\n    anno_identifier: Any | None = None,\n    user_identifier: Any | None = None,\n    auth_scope: list[str] | None = None,\n) -&gt; list[LimitRule]:\n    \"\"\"\n    Determines which rules should be applied for a given request.\n\n    :param scopes: ASGI request scope\n    :param anno_identifier: Anonymous user identifier (optional)\n    :param user_identifier: Authenticated user identifier (optional)\n    :param auth_scope: List of user scopes this rule applies to\n    :return: List of applicable rules\n    \"\"\"\n\n    rules = [rule for rule in self.rules if rule.is_enabled(scopes, anno_identifier, user_identifier, auth_scope)]\n\n    return rules\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.LimitRuleManager.add_rules","title":"add_rules","text":"<pre><code>add_rules(rule)\n</code></pre> <p>Adds a new rate limit rule to the collection.</p> <p>:param rule: LimitRule instance to add</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def add_rules(self, rule: LimitRule) -&gt; None:\n    \"\"\"\n    Adds a new rate limit rule to the collection.\n\n    :param rule: LimitRule instance to add\n    \"\"\"\n\n    self.rules.add(rule)\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.find_closure_rules_function","title":"find_closure_rules_function","text":"<pre><code>find_closure_rules_function(func)\n</code></pre> <p>Recursively finds a function with throttle rules in closure tree. Traverses through function closures using BFS.</p> <p>:param func: Function to search from :return: Function with throttle rules or None if not found</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def find_closure_rules_function(func):\n    \"\"\"\n    Recursively finds a function with throttle rules in closure tree.\n    Traverses through function closures using BFS.\n\n    :param func: Function to search from\n    :return: Function with throttle rules or None if not found\n    \"\"\"\n\n    queue = deque([func])\n    visited = set()\n\n    while queue:\n        current_func = queue.popleft()\n        if current_func in visited:\n            continue\n        visited.add(current_func)\n\n        if hasattr(current_func, THROTTLE_RULE_ATTR_NAME):\n            return current_func\n\n        if hasattr(current_func, \"__closure__\") and current_func.__closure__:\n            for cell in current_func.__closure__:\n                cell_content = cell.cell_contents\n                if callable(cell_content):\n                    queue.append(cell_content)\n\n    return None\n</code></pre>"},{"location":"reference/throttle/decorator/#webtool.throttle.decorator.limiter","title":"limiter","text":"<pre><code>limiter(\n    max_requests,\n    interval=3600,\n    throttle_key=None,\n    method=None,\n    scopes=None,\n)\n</code></pre> <p>Decorator for implementing rate limiting on functions.</p> <p>:param max_requests: Maximum number of requests allowed in the interval :param interval: Time interval in seconds (default: 3600) :param throttle_key: Custom key for the rate limit (default: function path) :param method: List of HTTP methods to apply limit to (optional) :param scopes: List of user scopes to apply limit to (optional) :return: Decorated function with rate limiting rules</p> Source code in <code>webtool/throttle/decorator.py</code> <pre><code>def limiter(\n    max_requests: Union[int, Callable[..., int]],\n    interval: int = 3600,\n    throttle_key: Optional[str] = None,\n    method: Optional[list[str]] = None,\n    scopes: Optional[list[str]] = None,\n):\n    \"\"\"\n    Decorator for implementing rate limiting on functions.\n\n    :param max_requests: Maximum number of requests allowed in the interval\n    :param interval: Time interval in seconds (default: 3600)\n    :param throttle_key: Custom key for the rate limit (default: function path)\n    :param method: List of HTTP methods to apply limit to (optional)\n    :param scopes: List of user scopes to apply limit to (optional)\n    :return: Decorated function with rate limiting rules\n    \"\"\"\n\n    def decorator(func):\n        exist_func = find_closure_rules_function(func)\n\n        key = throttle_key\n        if exist_func:\n            key = key or sha256(f\"{exist_func.__module__}{exist_func.__name__}{interval}{method}{scopes}\").hex()\n            if not hasattr(func, THROTTLE_RULE_ATTR_NAME):\n                exist_rules = getattr(exist_func, THROTTLE_RULE_ATTR_NAME)\n                setattr(func, THROTTLE_RULE_ATTR_NAME, exist_rules)\n        else:\n            key = key or sha256(f\"{func.__module__}{func.__name__}{interval}{method}{scopes}\").hex()\n            setattr(func, THROTTLE_RULE_ATTR_NAME, LimitRuleManager())\n\n        new_rule = LimitRule(\n            max_requests=max_requests,\n            interval=interval,\n            throttle_key=key,\n            method=[m.upper() for m in method] if method else [],\n            scopes=scopes or [],\n        )\n\n        getattr(func, THROTTLE_RULE_ATTR_NAME).add_rules(new_rule)\n\n        return func\n\n    return decorator\n</code></pre>"},{"location":"reference/throttle/limiter/","title":"throttle - limiter","text":""},{"location":"reference/throttle/limiter/#webtool.throttle.limiter.BaseLimiter","title":"BaseLimiter","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"reference/throttle/limiter/#webtool.throttle.limiter.BaseLimiter.is_deny","title":"is_deny  <code>abstractmethod</code>","text":"<pre><code>is_deny(identifier, rules)\n</code></pre> <p>Checks if any rate limits are exceeded.</p> <p>:param identifier: User or session identifier :param rules: List of rate limit rules to check :return: List of waiting times until rate limits reset (empty if not exceeded)</p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>@abstractmethod\ndef is_deny(self, identifier: str, rules: list[LimitRule]) -&gt; list[float]:\n    \"\"\"\n    Checks if any rate limits are exceeded.\n\n    :param identifier: User or session identifier\n    :param rules: List of rate limit rules to check\n    :return: List of waiting times until rate limits reset (empty if not exceeded)\n    \"\"\"\n\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/throttle/limiter/#webtool.throttle.limiter.RedisLimiter","title":"RedisLimiter","text":"<pre><code>RedisLimiter(redis_cache)\n</code></pre> <p>               Bases: <code>BaseLimiter</code></p> <p>Rate limiter implementation using Redis for distributed rate limiting.</p> <p>:param redis: Redis client instance</p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>def __init__(self, redis_cache: RedisCache):\n    \"\"\"\n    :param redis: Redis client instance\n    \"\"\"\n\n    self._cache = redis_cache.cache\n    self._redis_function = self._cache.register_script(RedisLimiter._LUA_LIMITER_SCRIPT)\n    self._json_encoder = ORJSONEncoder()\n    self._json_decoder = ORJSONDecoder()\n</code></pre>"},{"location":"reference/throttle/limiter/#webtool.throttle.limiter.RedisLimiter.is_deny","title":"is_deny  <code>async</code>","text":"<pre><code>is_deny(identifier, rules)\n</code></pre> <p>Checks if any rate limits are exceeded.</p> <p>:param identifier: User or session identifier :param rules: List of rate limit rules to check :return: List of waiting times until rate limits reset (empty if not exceeded)</p> Source code in <code>webtool/throttle/limiter.py</code> <pre><code>async def is_deny(self, identifier: str, rules: list[LimitRule]) -&gt; list[float]:\n    \"\"\"\n    Checks if any rate limits are exceeded.\n\n    :param identifier: User or session identifier\n    :param rules: List of rate limit rules to check\n    :return: List of waiting times until rate limits reset (empty if not exceeded)\n    \"\"\"\n\n    ruleset = self._get_ruleset(identifier, rules)\n\n    result = await self._get_limits(ruleset)\n    now = asyncio.get_running_loop().time()\n    deny = [float(val[2]) + ruleset[key][1] - now for key, val in result.items() if val[0] &lt; val[1]]\n\n    return deny\n</code></pre>"},{"location":"reference/throttle/middleware/","title":"throttle - middleware","text":""},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware","title":"LimitMiddleware","text":"<pre><code>LimitMiddleware(\n    app, cache, auth_backend, anno_backend=None\n)\n</code></pre> <p>Middleware for implementing rate limiting in ASGI applications.</p> <p>This middleware supports both authenticated and anonymous users, applying rate limits based on user identifiers or session IDs.</p> <p>:param app: ASGI application :param cache: Cache client instance for storing rate limit data :param auth_backend: Authentication backend for identifying users :param anno_backend: Backend for handling anonymous users (defaults to AnnoSessionBackend)</p> Source code in <code>webtool/throttle/middleware.py</code> <pre><code>def __init__(\n    self,\n    app,\n    cache,\n    auth_backend: \"BaseBackend\",\n    anno_backend: \"BaseAnnoBackend\" = None,\n) -&gt; None:\n    \"\"\"\n    :param app: ASGI application\n    :param cache: Cache client instance for storing rate limit data\n    :param auth_backend: Authentication backend for identifying users\n    :param anno_backend: Backend for handling anonymous users (defaults to AnnoSessionBackend)\n    \"\"\"\n\n    self.app = app\n    self.limiter = RedisLimiter(cache)\n    self.limit = None\n    self.auth_backend = auth_backend\n    self.anno_backend = anno_backend or AnnoSessionBackend(\"th-session\")\n</code></pre>"},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.limiter","title":"limiter  <code>instance-attribute</code>","text":"<pre><code>limiter = RedisLimiter(cache)\n</code></pre>"},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.limit","title":"limit  <code>instance-attribute</code>","text":"<pre><code>limit = None\n</code></pre>"},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.auth_backend","title":"auth_backend  <code>instance-attribute</code>","text":"<pre><code>auth_backend = auth_backend\n</code></pre>"},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.anno_backend","title":"anno_backend  <code>instance-attribute</code>","text":"<pre><code>anno_backend = anno_backend or AnnoSessionBackend(\n    \"th-session\"\n)\n</code></pre>"},{"location":"reference/throttle/middleware/#webtool.throttle.middleware.LimitMiddleware.apply","title":"apply  <code>async</code>","text":"<pre><code>apply(scope, receive, send, identifier, rules)\n</code></pre> <p>Applies rate limiting rules and handles the request.</p> <p>:param scope: ASGI request scope :param receive: ASGI receive function :param send: ASGI send function :param identifier: ASGI identifier string :param rules: List of rate limit rules</p> <p>:return: Response from app or rate limit exceeded response</p> Source code in <code>webtool/throttle/middleware.py</code> <pre><code>async def apply(self, scope, receive, send, identifier: str, rules: list[\"LimitRule\"]):\n    \"\"\"\n    Applies rate limiting rules and handles the request.\n\n    :param scope: ASGI request scope\n    :param receive: ASGI receive function\n    :param send: ASGI send function\n    :param identifier: ASGI identifier string\n    :param rules: List of rate limit rules\n\n    :return: Response from app or rate limit exceeded response\n    \"\"\"\n\n    if rules:\n        deny = await self.limiter.is_deny(identifier, rules)\n        if deny:\n            return await _default_callback(scope, send, int(max(deny)))\n\n    return await self.app(scope, receive, send)\n</code></pre>"},{"location":"reference/utils/json/","title":"throttle - backend","text":""},{"location":"reference/utils/json/#webtool.utils.json.PyORJSONDecoder","title":"PyORJSONDecoder  <code>module-attribute</code>","text":"<pre><code>PyORJSONDecoder = cast(type[JSONDecoder], _PyORJSONDecoder)\n</code></pre> <p>Compatible with Python's <code>json.JSONDecoder</code>. The <code>typing.cast</code> function Cast to a <code>json.JSONDecoder</code>.</p>"},{"location":"reference/utils/json/#webtool.utils.json.PyORJSONEncoder","title":"PyORJSONEncoder  <code>module-attribute</code>","text":"<pre><code>PyORJSONEncoder = cast(type[JSONEncoder], _PyORJSONEncoder)\n</code></pre> <p>Compatible with Python's <code>json.JSONEncoder</code>. The <code>typing.cast</code> function Cast to a <code>json.JSONEncoder</code>.</p>"},{"location":"reference/utils/json/#webtool.utils.json.ORJSONEncoder","title":"ORJSONEncoder","text":"<p>ORJSON Encoder Class</p>"},{"location":"reference/utils/json/#webtool.utils.json.ORJSONEncoder.encode","title":"encode  <code>staticmethod</code>","text":"<pre><code>encode(o)\n</code></pre> Source code in <code>webtool/utils/json.py</code> <pre><code>@staticmethod\ndef encode(o):\n    return orjson.dumps(o)\n</code></pre>"},{"location":"reference/utils/json/#webtool.utils.json.ORJSONDecoder","title":"ORJSONDecoder","text":"<p>ORJSON Decoder Class</p>"},{"location":"reference/utils/json/#webtool.utils.json.ORJSONDecoder.decode","title":"decode  <code>staticmethod</code>","text":"<pre><code>decode(s, *args)\n</code></pre> Source code in <code>webtool/utils/json.py</code> <pre><code>@staticmethod\ndef decode(s, *args):\n    return orjson.loads(s)\n</code></pre>"},{"location":"reference/utils/key/","title":"throttle - backend","text":""},{"location":"reference/utils/key/#webtool.utils.key.AllowedPrivateKeys","title":"AllowedPrivateKeys  <code>module-attribute</code>","text":"<pre><code>AllowedPrivateKeys = (\n    RSAPrivateKey\n    | EllipticCurvePrivateKey\n    | Ed25519PrivateKey\n    | Ed448PrivateKey\n)\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.AllowedPublicKeys","title":"AllowedPublicKeys  <code>module-attribute</code>","text":"<pre><code>AllowedPublicKeys = (\n    RSAPublicKey\n    | EllipticCurvePublicKey\n    | Ed25519PublicKey\n    | Ed448PublicKey\n)\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.make_symmetric_key","title":"make_symmetric_key","text":"<pre><code>make_symmetric_key(key_bytes=32, save=False)\n</code></pre> Source code in <code>webtool/utils/key.py</code> <pre><code>def make_symmetric_key(key_bytes: int = 32, save: bool = False) -&gt; bytes:\n    key = base64.urlsafe_b64encode(secrets.token_bytes(key_bytes))\n\n    if save:\n        _save_key(key, \"symmetric_key\")\n\n    return key\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.make_rsa_key","title":"make_rsa_key","text":"<pre><code>make_rsa_key(key_size=2048, save=False, password=None)\n</code></pre> Source code in <code>webtool/utils/key.py</code> <pre><code>def make_rsa_key(key_size: int = 2048, save: bool = False, password: str | bytes | None = None) -&gt; bytes:\n    if key_size &lt; 2048:\n        raise ValueError(\"Key size must be greater than or equal to 2048\")\n\n    private_key = rsa.generate_private_key(\n        public_exponent=65537,\n        key_size=key_size,\n    )\n\n    private_key = _serialize_key(private_key, password=password)\n\n    if save:\n        _save_key(private_key, \"rsa_private_key\")\n\n    return private_key\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.make_ec_key","title":"make_ec_key","text":"<pre><code>make_ec_key(algorithm='ES256', save=False, password=None)\n</code></pre> Source code in <code>webtool/utils/key.py</code> <pre><code>def make_ec_key(algorithm: str = \"ES256\", save: bool = False, password: str | bytes | None = None) -&gt; bytes:\n    algorithm = algorithm.upper()\n\n    if algorithm == \"ES256\":\n        private_key = ec.generate_private_key(ec.SECP256R1())\n    elif algorithm == \"ES256K\":\n        private_key = ec.generate_private_key(ec.SECP256K1())\n    elif algorithm == \"ES384\":\n        private_key = ec.generate_private_key(ec.SECP384R1())\n    elif algorithm == \"ES512\":\n        private_key = ec.generate_private_key(ec.SECP521R1())\n    else:\n        raise ValueError(\"Algorithm must be ES256, ES256K, ES384, ES512\")\n\n    private_key = _serialize_key(private_key, password=password)\n\n    if save:\n        _save_key(private_key, \"ec_private_key\")\n\n    return private_key\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.make_ed_key","title":"make_ed_key","text":"<pre><code>make_ed_key(algorithm='ed25519', save=False, password=None)\n</code></pre> Source code in <code>webtool/utils/key.py</code> <pre><code>def make_ed_key(algorithm: str = \"ed25519\", save: bool = False, password: str | bytes | None = None) -&gt; bytes:\n    algorithm = algorithm.upper()\n\n    if algorithm == \"ED25519\":\n        private_key = ed25519.Ed25519PrivateKey.generate()\n    elif algorithm == \"ED448\":\n        private_key = ed448.Ed448PrivateKey.generate()\n    else:\n        raise ValueError(\"Curve must be Ed25519 or Ed448\")\n\n    private_key = _serialize_key(private_key, password=password)\n\n    if save:\n        _save_key(private_key, \"ed_private_key\")\n\n    return private_key\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.load_asymmetric_key","title":"load_asymmetric_key","text":"<pre><code>load_asymmetric_key(private_key, password=None)\n</code></pre> Source code in <code>webtool/utils/key.py</code> <pre><code>def load_asymmetric_key(\n    private_key: bytes,\n    password: str | bytes | None = None,\n) -&gt; tuple[AllowedPrivateKeys, AllowedPublicKeys, str] | None:\n    if isinstance(password, str):\n        password = password.encode(\"utf-8\")\n\n    try:\n        private_key = load_pem_private_key(private_key, password=password)\n    except ValueError:\n        return None\n\n    public_key = private_key.public_key()\n\n    if isinstance(private_key, rsa.RSAPrivateKey):\n        key_size = private_key.key_size\n        if key_size &lt; 3072:\n            algorithm = \"RS256\"\n        elif key_size &lt; 4096:\n            algorithm = \"RS384\"\n        else:\n            algorithm = \"RS512\"\n    elif isinstance(private_key, ec.EllipticCurvePrivateKey):\n        curve = private_key.curve.name\n        if curve == \"secp256r1\":\n            algorithm = \"ES256\"\n        elif curve == \"secp256k1\":\n            algorithm = \"ES256K\"\n        elif curve == \"secp384r1\":\n            algorithm = \"ES384\"\n        elif curve == \"secp521r1\":\n            algorithm = \"ES512\"\n        else:\n            raise ValueError(\n                f\"Unsupported elliptic curve: {curve}. \"\n                \"Supported curves are secp256r1, secp256k1, secp384r1, and secp521r1.\"\n            )\n    elif isinstance(private_key, (ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey)):\n        algorithm = \"EdDSA\"\n    else:\n        raise ValueError(\n            f\"Unsupported key type: {type(private_key).__name__}. \"\n            \"Supported key types are RSAPrivateKey, EllipticCurvePrivateKey, Ed25519PrivateKey, and Ed448PrivateKey.\"\n        )\n\n    return private_key, public_key, algorithm\n</code></pre>"},{"location":"reference/utils/key/#webtool.utils.key.load_key","title":"load_key","text":"<pre><code>load_key(key, password=None)\n</code></pre> Source code in <code>webtool/utils/key.py</code> <pre><code>def load_key(\n    key: bytes | str,\n    password: str | bytes | None = None,\n) -&gt; tuple[AllowedPrivateKeys, AllowedPublicKeys, str] | tuple[bytes | str, str] | None:\n    if isinstance(key, bytes):\n        key_cart = load_asymmetric_key(key, password)\n\n        if key_cart:\n            return key_cart\n\n    key_size = len(key)\n\n    if key_size &lt; 48:\n        key, algorithm = key, \"HS256\"\n    elif key_size &lt; 64:\n        key, algorithm = key, \"HS384\"\n    else:\n        key, algorithm = key, \"HS512\"\n\n    return key, algorithm\n</code></pre>"},{"location":"resources/CONTRIBUTING/","title":"Development - Contributing","text":""},{"location":"resources/CONTRIBUTING/#developing","title":"Developing","text":"<p>If you already cloned the webtool repository and you want to deep dive in the code, here are some guidelines to set up your environment.</p>"},{"location":"resources/CONTRIBUTING/#virtual-environment","title":"Virtual environment","text":"<p>Follow the instructions to create and activate a virtual environment with Poetry for the internal code of webtool.</p>"},{"location":"resources/CONTRIBUTING/#install-requirements-using-poetry","title":"Install requirements using poetry","text":"<p>After activating the environment, install the required packages:</p> <pre><code> poetry install\n</code></pre>"},{"location":"resources/CONTRIBUTING/#using-your-local-webtool","title":"Using your local Webtool","text":"<p>If you create a Python file that imports and uses Webtool, and run it with the Python from your local environment, it will use your cloned local Webtool source code.</p> <p>And if you update that local Webtool source code when you run that Python file again, it will use the fresh version of Webtool you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p>"},{"location":"resources/CONTRIBUTING/#format-the-code","title":"Format the code","text":"<p>There is a script that you can run that will format and clean all your code:</p> <pre><code>poetry run ruff check\n</code></pre> <p>There is a script that you can run locally to test all the code and generate coverage reports:</p> <pre><code>poetry run coverage run --omit=\"tests*\" -m pytest\n</code></pre>"},{"location":"resources/CONTRIBUTING/#docs","title":"Docs","text":"<p>First, make sure you set up your environment as described above, that will install all the requirements.</p>"},{"location":"resources/CONTRIBUTING/#docs-live","title":"Docs live","text":"<p>During local development, there is a script that builds the site and checks for any changes, live-reloading:</p> <pre><code>mkdocs serve\n</code></pre> <p>It will serve the documentation on http://127.0.0.1:8000.</p> <p>You can also run docs live with other port</p> <pre><code>mkdocs serve -a localhost:8001\n</code></pre> <p>That way, you can edit the documentation/source files and see the changes live.</p>"},{"location":"resources/CONTRIBUTING/#docs-structure","title":"Docs Structure","text":"<p>The documentation uses MkDocs.</p>"}]}