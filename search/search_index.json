{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebTool(Alpha)","text":"<p>WebTool is Well-Architected FastAPI/Starlette library for authentication, throttling, caching, logging, and utilities.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install webtool\n</code></pre> <pre><code>poetry add webtool\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#authentication","title":"Authentication","text":"<p>JWT token management system with Redis-backed refresh tokens.</p> <pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache_client = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache_client)\n\n\nasync def get_token():\n    access_token = jwt_service.create_access_token({\"sub\": 123, \"scope\": [\"write\"]})\n    refresh_token = await jwt_service.create_refresh_token({\"sub\": 123}, access_token)\n    return access_token, refresh_token\n</code></pre>"},{"location":"#throttling","title":"Throttling","text":"<p>Rate limiting system for FastAPI/Starlette applications.</p> <pre><code>from fastapi import FastAPI\nfrom starlette.middleware import Middleware\nfrom webtool.auth import JWTService\nfrom webtool.cache import RedisCache\nfrom webtool.throttle import limiter, LimitMiddleware, JWTBackend\n\ncache = RedisCache(\"redis://127.0.0.1:6379/0\")\njwt_backend = JWTBackend(JWTService(cache, secret_key=\"test\"))\n\napp = FastAPI(\n    middleware=[\n        Middleware(\n            LimitMiddleware,\n            cache=cache,\n            auth_backend=jwt_backend,\n        ),\n    ],\n)\n\n\n@app.get(\"/api/resource\")\n@limiter(max_requests=50, interval=3600, scope=[\"user\"])\n@limiter(max_requests=10, interval=3600, scope=[\"anno\"])\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#msgpack-response","title":"MsgPack Response","text":"<p>MessagePack-based response.</p> <pre><code>from webtool.utils import MsgSpecJSONResponse\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    default_response_class=MsgSpecJSONResponse,\n)\n\n\n@app.get(\"/api/resource\")\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache-2.0 License.</p>"},{"location":"modules/manager/","title":"Auth - manager","text":"<p>This module provides functionality for handling JSON Web Tokens (JWT) for authentication and authorization. It defines the structure and methods required to encode and decode JWTs, as well as manage the claims associated with the tokens.</p>"},{"location":"modules/manager/#tokendata-class","title":"TokenData Class","text":"<p>The <code>TokenData</code> class represents the claims embedded in a JWT. It is a typed dictionary (<code>TypedDict</code>) that ensures type safety when working with JWTs.</p> <pre><code>class TokenData(TypedDict):\n    sub: str\n    exp: float\n    iat: float\n    jti: str\n    scope: NotRequired[list[str]]\n</code></pre> <p>Field Descriptions:</p> <ul> <li><code>sub</code>: Unique identifier for the subject.</li> <li><code>exp</code>: Expiration time (defaults if not provided).</li> <li><code>iat</code>: Issued at time (defaults if not provided).</li> <li><code>jti</code>: JWT ID (defaults if not provided).</li> <li><code>scope</code>: Optional list of scopes for fine-grained access control.</li> </ul>"},{"location":"modules/manager/#basejwtmanager-class","title":"BaseJWTManager Class","text":"<p>Abstract base class for managing JWTs, defining the interface for encoding and decoding JWTs.</p> <p>Methods:</p> <ul> <li> <p><code>encode(claims, secret_key, algorithm, access_token) -&gt; str</code> Encodes claims into a JWT.</p> </li> <li> <p><code>decode(token, secret_key, algorithm, access_token) -&gt; str</code> Decodes and validates a JWT.</p> </li> </ul>"},{"location":"modules/manager/#jwtmanager-class","title":"JWTManager Class","text":"<p>JWTManager is an implementation of 'BaseJWTManager' using python-jose. responsible for encoding and decoding JSON Web Tokens (JWT). The JWTManager class follows the Apache Software Foundation (ASF) coding style guidelines, providing clear and concise documentation for its methods and parameters.</p> <ul> <li> <p><code>encode(claims, secret_key, algorithm, access_token) -&gt; str</code> This method takes the JWT claims, secret key, signing algorithm, and an optional access token parameter, and returns the encoded JWT string.</p> </li> <li> <p><code>decode(token, secret_key, algorithm, access_token) -&gt; str</code>: This method takes the JWT token string, secret key, signing algorithm, and an optional access token parameter, and returns the decoded claims if the token is valid, or None if the token is invalid or expired.</p> </li> </ul>"},{"location":"modules/manager/#usage","title":"Usage","text":"<p>In most cases, JWTManager is not used directly</p> <pre><code>from webtool.auth import JWTManager\n\nmanager = JWTManager()\n\naccess_token = manager.encode({\n    \"sub\": \"1\", \n    \"exp\": 1, \n    \"iat\": 123, \n    \"jti\": \"abc\",\n    \"scope\": [\"user\"]\n}, secret_key=\"your_secret_key\", algorithm='HS256')\n</code></pre>"},{"location":"modules/service/","title":"Auth - Service","text":""},{"location":"modules/service/#jwtservice","title":"JWTService","text":"<p>The JWTService class provides an abstraction for managing JSON Web Tokens (JWT), including creation, validation, and invalidation of both access and refresh tokens. Designed for flexibility, it supports multiple caching backends via the BaseCache interface and enables extensibility for custom JWT handling with BaseJWTManager.</p>"},{"location":"modules/service/#parameters","title":"Parameters","text":"<p>The class accepts the following configuration during initialization: - <code>cache</code>: An instance of BaseCache, used for managing token-related data storage.  - <code>jwt_manager</code> (optional): An instance of BaseJWTManager (or its subclass). Defaults to JWTManager.  - <code>secret_key</code>: A secret key for signing JWT tokens.  - <code>algorithm</code>: The signing algorithm. Defaults to HS384.  - <code>access_token_expire_time</code>: Expiration time for access tokens in seconds. Default: 3600 seconds (1 hour).  - <code>refresh_token_expire_time</code>: Expiration time for refresh tokens in seconds. Default: 604800 seconds (1 week).</p>"},{"location":"modules/service/#features","title":"Features","text":"<ul> <li>Access Token Management: Create and validate short-lived access tokens. </li> <li>Refresh Token Management: Generate refresh tokens, store metadata in a cache, and validate them. </li> <li>Token Invalidation: Support for securely invalidating tokens to prevent further use. </li> <li>Token Updates: Enable Refresh Token Rotation(RTR).</li> <li>Customizability: Use the BaseJWTService interface to create tailored implementations for unique requirements.</li> </ul>"},{"location":"modules/service/#usage-example","title":"Usage Example","text":"<pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache, secret_key=\"your_secret_key\")\n\nasync def create_tokens():\n    user_data = {\"sub\": \"user123\"}\n    access, refresh = await jwt_service.create_token(user_data)\n    return access, refresh\n</code></pre>"},{"location":"modules/service/#redisjwtservice","title":"RedisJWTService","text":"<p>RedisJWTService extends JWTService with Redis-specific optimizations, leveraging Lua scripting for atomic operations. It is ideal for high-performance environments requiring efficient token storage and management.</p>"},{"location":"modules/service/#additional-features","title":"Additional Features","text":"<ul> <li>Optimized Token Storage: Uses Redis\u2019s native commands and Lua scripts for efficient token management. </li> <li>Atomic Invalidation: Ensures secure and consistent token invalidation using Lua scripts. </li> <li>Search Capability: Provides functionality to retrieve all active refresh tokens for a user (sub), supporting session-based authentication management.</li> </ul>"},{"location":"modules/service/#lua-scripts","title":"Lua Scripts","text":"<ul> <li>Save Token Script: Atomically stores refresh tokens and associates them with access tokens. </li> <li>Invalidate Token Script: Invalidates access and refresh tokens while cleaning up associated metadata. </li> <li>Search Token Script: Fetches refresh tokens for a specific user and removes expired tokens.</li> </ul>"},{"location":"modules/service/#usage-example_1","title":"Usage Example","text":"<pre><code>import asyncio\nfrom webtool.auth import RedisJWTService\nfrom webtool.cache import RedisCache\n\ncache = RedisCache(\"redis://localhost:6379/0\")\nredis_jwt_service = RedisJWTService(cache, secret_key=\"your_secret_key\")\n\nasync def manage_tokens():\n    user_data = {\"sub\": \"user123\"}\n    access, refresh = await redis_jwt_service.create_token(user_data)\n    print(\"Access Token:\", access)\n    print(\"Refresh Token:\", refresh)\n\n    # Validate tokens\n    access_data = await redis_jwt_service.validate_access_token(access)\n    print(\"Access Token Data:\", access_data)\n\n    refresh_data = await redis_jwt_service.validate_refresh_token(access, refresh)\n    print(\"Refresh Token Data:\", refresh_data)\n\n    # Rotate tokens\n    new_access, new_refresh = await redis_jwt_service.update_token(user_data, access, refresh)\n    print(\"New Access Token:\", new_access)\n    print(\"New Refresh Token:\", new_refresh)\n\n    # Search active tokens\n    active_tokens = await redis_jwt_service.search_token(new_access, new_refresh)\n    print(\"Active Refresh Tokens:\", active_tokens)\n\n# Example usage\nasyncio.run(manage_tokens())\n</code></pre>"}]}