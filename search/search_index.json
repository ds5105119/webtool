{"config":{"lang":["en","ko"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"WebTool(Alpha)","text":"<p>WebTool is Well-Architected FastAPI/Starlette library for authentication, throttling, caching, logging, and utilities.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install webtool\n</code></pre> <pre><code>poetry add webtool\n</code></pre>"},{"location":"#features","title":"Features","text":""},{"location":"#authentication","title":"Authentication","text":"<p>JWT token management system with Redis-backed refresh tokens.</p> <pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache_client = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache_client)\n\n\nasync def get_token():\n    access, refresh = jwt_service.create_token({\"sub\": 123, \"scope\": [\"write\"]})\n    return access, refresh\n</code></pre>"},{"location":"#throttling","title":"Throttling","text":"<p>Rate limiting system for FastAPI/Starlette applications.</p> <pre><code>from fastapi import FastAPI\nfrom starlette.middleware import Middleware\nfrom webtool.auth import JWTService\nfrom webtool.cache import RedisCache\nfrom webtool.throttle import limiter, LimitMiddleware, JWTBackend\n\ncache = RedisCache(\"redis://127.0.0.1:6379/0\")\njwt_backend = JWTBackend(JWTService(cache, secret_key=\"test\"))\n\napp = FastAPI(\n    middleware=[\n        Middleware(\n            LimitMiddleware,\n            cache=cache,\n            auth_backend=jwt_backend,\n        ),\n    ],\n)\n\n\n@app.get(\"/api/resource\")\n@limiter(max_requests=50, interval=3600, scopes=[\"user\"])\n@limiter(max_requests=10, interval=3600, scopes=[\"anno\"])\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#msgpack-response","title":"MsgPack Response","text":"<p>MessagePack-based response.</p> <pre><code>from webtool.utils import MsgSpecJSONResponse\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    default_response_class=MsgSpecJSONResponse,\n)\n\n\n@app.get(\"/api/resource\")\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the Apache-2.0 License.</p>"},{"location":"docs/manager/","title":"Auth - manager","text":"<p>This module provides functionality for handling JSON Web Tokens (JWT) for authentication and authorization. It defines the structure and methods required to encode and decode JWTs, as well as manage the claims associated with the tokens.</p>"},{"location":"docs/manager/#tokendata-class","title":"TokenData Class","text":"<p>The <code>TokenData</code> class represents the claims embedded in a JWT. It is a typed dictionary (<code>TypedDict</code>) that ensures type safety when working with JWTs.</p> <pre><code>class TokenData(TypedDict):\n    sub: str\n    exp: float\n    iat: float\n    jti: str\n    scope: NotRequired[list[str]]\n</code></pre> <p>Field Descriptions:</p> <ul> <li><code>sub</code>: Unique identifier for the subject.</li> <li><code>exp</code>: Expiration time (defaults if not provided).</li> <li><code>iat</code>: Issued at time (defaults if not provided).</li> <li><code>jti</code>: JWT ID (defaults if not provided).</li> <li><code>scope</code>: Optional list of scopes for fine-grained access control.</li> </ul>"},{"location":"docs/manager/#basejwtmanager-class","title":"BaseJWTManager Class","text":"<p>Abstract base class for managing JWTs, defining the interface for encoding and decoding JWTs.</p> <p>Methods:</p> <ul> <li> <p><code>encode(claims, secret_key, algorithm, access_token) -&gt; str</code> Encodes claims into a JWT.</p> </li> <li> <p><code>decode(token, secret_key, algorithm, access_token) -&gt; str</code> Decodes and validates a JWT.</p> </li> </ul>"},{"location":"docs/manager/#jwtmanager-class","title":"JWTManager Class","text":"<p>JWTManager is an implementation of 'BaseJWTManager' using python-jose. responsible for encoding and decoding JSON Web Tokens (JWT). The JWTManager class follows the Apache Software Foundation (ASF) coding style guidelines, providing clear and concise documentation for its methods and parameters.</p> <ul> <li> <p><code>encode(claims, secret_key, algorithm, access_token) -&gt; str</code> This method takes the JWT claims, secret key, signing algorithm, and an optional access token parameter, and returns the encoded JWT string.</p> </li> <li> <p><code>decode(token, secret_key, algorithm, access_token) -&gt; str</code>: This method takes the JWT token string, secret key, signing algorithm, and an optional access token parameter, and returns the decoded claims if the token is valid, or None if the token is invalid or expired.</p> </li> </ul>"},{"location":"docs/manager/#usage","title":"Usage","text":"<p>In most cases, JWTManager is not used directly</p> <pre><code>from webtool.auth import JWTManager\n\nmanager = JWTManager()\n\naccess_token = manager.encode({\n    \"sub\": \"1\", \n    \"exp\": 1, \n    \"iat\": 123, \n    \"jti\": \"abc\",\n    \"scope\": [\"user\"]\n}, secret_key=\"your_secret_key\", algorithm='HS256')\n</code></pre>"},{"location":"docs/service/","title":"Auth - Service","text":""},{"location":"docs/service/#jwtservice","title":"JWTService","text":"<p>The JWTService class provides an abstraction for managing JSON Web Tokens (JWT), including creation, validation, and invalidation of both access and refresh tokens. Designed for flexibility, it supports multiple caching backends via the BaseCache interface and enables extensibility for custom JWT handling with BaseJWTManager.</p>"},{"location":"docs/service/#parameters","title":"Parameters","text":"<p>The class accepts the following configuration during initialization: - <code>cache</code>: An instance of BaseCache, used for managing token-related data storage.  - <code>jwt_manager</code> (optional): An instance of BaseJWTManager (or its subclass). Defaults to JWTManager.  - <code>secret_key</code>: A secret key for signing JWT tokens.  - <code>algorithm</code>: The signing algorithm. Defaults to HS384.  - <code>access_token_expire_time</code>: Expiration time for access tokens in seconds. Default: 3600 seconds (1 hour).  - <code>refresh_token_expire_time</code>: Expiration time for refresh tokens in seconds. Default: 604800 seconds (1 week).</p>"},{"location":"docs/service/#features","title":"Features","text":"<ul> <li>Access Token Management: Create and validate short-lived access tokens. </li> <li>Refresh Token Management: Generate refresh tokens, store metadata in a cache, and validate them. </li> <li>Token Invalidation: Support for securely invalidating tokens to prevent further use. </li> <li>Token Updates: Enable Refresh Token Rotation(RTR).</li> <li>Customizability: Use the BaseJWTService interface to create tailored implementations for unique requirements.</li> </ul>"},{"location":"docs/service/#usage-example","title":"Usage Example","text":"<pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache, secret_key=\"your_secret_key\")\n\nasync def create_tokens():\n    user_data = {\"sub\": \"user123\"}\n    access, refresh = await jwt_service.create_token(user_data)\n    return access, refresh\n</code></pre>"},{"location":"docs/service/#redisjwtservice","title":"RedisJWTService","text":"<p>RedisJWTService extends JWTService with Redis-specific optimizations, leveraging Lua scripting for atomic operations. It is ideal for high-performance environments requiring efficient token storage and management.</p>"},{"location":"docs/service/#additional-features","title":"Additional Features","text":"<ul> <li>Optimized Token Storage: Uses Redis\u2019s native commands and Lua scripts for efficient token management. </li> <li>Atomic Invalidation: Ensures secure and consistent token invalidation using Lua scripts. </li> <li>Search Capability: Provides functionality to retrieve all active refresh tokens for a user (sub), supporting session-based authentication management.</li> </ul>"},{"location":"docs/service/#lua-scripts","title":"Lua Scripts","text":"<ul> <li>Save Token Script: Atomically stores refresh tokens and associates them with access tokens. </li> <li>Invalidate Token Script: Invalidates access and refresh tokens while cleaning up associated metadata. </li> <li>Search Token Script: Fetches refresh tokens for a specific user and removes expired tokens.</li> </ul>"},{"location":"docs/service/#usage-example_1","title":"Usage Example","text":"<pre><code>import asyncio\nfrom webtool.auth import RedisJWTService\nfrom webtool.cache import RedisCache\n\ncache = RedisCache(\"redis://localhost:6379/0\")\nredis_jwt_service = RedisJWTService(cache, secret_key=\"your_secret_key\")\n\nasync def manage_tokens():\n    user_data = {\"sub\": \"user1234\"}\n    access, refresh = await redis_jwt_service.create_token(user_data)\n    print(\"Access Token:\", access)\n    print(\"Refresh Token:\", refresh)\n\n    # Validate tokens\n    access_data = await redis_jwt_service.validate_access_token(access)\n    print(\"Access Token Data:\", access_data)\n\n    refresh_data = await redis_jwt_service.validate_refresh_token(access, refresh)\n    print(\"Refresh Token Data:\", refresh_data)\n\n    # Rotate tokens\n    new_access, new_refresh = await redis_jwt_service.update_token(user_data, access, refresh)\n    print(\"New Access Token:\", new_access)\n    print(\"New Refresh Token:\", new_refresh)\n\n    # Search active tokens\n    access_2, refresh_2 = await redis_jwt_service.create_token(user_data)\n    active_tokens = await redis_jwt_service.search_token(new_access, new_refresh)\n    print(\"Active Refresh Tokens:\", active_tokens)\n\n    # You can invalidate your tokens (Invalidate access_2, refresh_2)\n    await redis_jwt_service.invalidate_token(new_access, new_refresh, active_tokens[1])\n    await redis_jwt_service.invalidate_token(new_access, new_refresh)\n\n    active_tokens = await redis_jwt_service.search_token(new_access, new_refresh)\n    print(\"Active Refresh Tokens:\", active_tokens)\n\n# Example usage\nasyncio.run(manage_tokens())\n</code></pre>"},{"location":"resources/CONTRIBUTING/","title":"Development - Contributing","text":""},{"location":"resources/CONTRIBUTING/#developing","title":"Developing","text":"<p>If you already cloned the webtool repository and you want to deep dive in the code, here are some guidelines to set up your environment.</p>"},{"location":"resources/CONTRIBUTING/#virtual-environment","title":"Virtual environment","text":"<p>Follow the instructions to create and activate a virtual environment with Poetry for the internal code of webtool.</p>"},{"location":"resources/CONTRIBUTING/#install-requirements-using-poetry","title":"Install requirements using poetry","text":"<p>After activating the environment, install the required packages:</p> <pre><code> poetry install\n</code></pre>"},{"location":"resources/CONTRIBUTING/#using-your-local-webtool","title":"Using your local Webtool","text":"<p>If you create a Python file that imports and uses Webtool, and run it with the Python from your local environment, it will use your cloned local Webtool source code.</p> <p>And if you update that local Webtool source code when you run that Python file again, it will use the fresh version of Webtool you just edited.</p> <p>That way, you don't have to \"install\" your local version to be able to test every change.</p>"},{"location":"resources/CONTRIBUTING/#format-the-code","title":"Format the code","text":"<p>There is a script that you can run that will format and clean all your code:</p> <pre><code>poetry run ruff check\n</code></pre> <p>There is a script that you can run locally to test all the code and generate coverage reports:</p> <pre><code>poetry run coverage run --omit=\"tests*\" -m pytest\n</code></pre>"},{"location":"resources/CONTRIBUTING/#docs","title":"Docs","text":"<p>First, make sure you set up your environment as described above, that will install all the requirements.</p>"},{"location":"resources/CONTRIBUTING/#docs-live","title":"Docs live","text":"<p>During local development, there is a script that builds the site and checks for any changes, live-reloading:</p> <pre><code>mkdocs serve\n</code></pre> <p>It will serve the documentation on http://127.0.0.1:8000.</p> <p>You can also run docs live with other port</p> <pre><code>mkdocs serve -a localhost:8001\n</code></pre> <p>That way, you can edit the documentation/source files and see the changes live.</p>"},{"location":"resources/CONTRIBUTING/#docs-structure","title":"Docs Structure","text":"<p>The documentation uses MkDocs.</p>"},{"location":"ko/","title":"WebTool(Alpha)","text":"<p>FastAPI/Starlette\ub97c \uc704\ud55c JWT\uc778\uc99d \ubc0f \uc2a4\ub85c\ud2c0\ub9c1, \uce90\uc2f1, \ub85c\uae45 \ub4f1\uc744 \uc704\ud55c \ub77c\uc774\ube0c\ub7ec\ub9ac.</p>"},{"location":"ko/#_1","title":"\uc694\uad6c \uc0ac\ud56d","text":"<ul> <li>Python 3.11+</li> </ul>"},{"location":"ko/#_2","title":"\uc124\uce58","text":"<pre><code>pip install webtool\n</code></pre> <pre><code>poetry add webtool\n</code></pre>"},{"location":"ko/#_3","title":"\uae30\ub2a5","text":""},{"location":"ko/#jwt","title":"JWT \uc778\uc99d","text":"<p>Redis \ub610\ub294 InMemory Cache \ubc31\uc5d4\ub4dc\ub97c \uc0ac\uc6a9\ud558\uc5ec RTR\uc804\ub7b5\uc73c\ub85c access token\uacfc refresh token\uc744 \uad00\ub9ac\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <pre><code>from webtool.auth import JWTService\nfrom webtool.cache import RedisCache\n\ncache_client = RedisCache(\"redis://localhost:6379/0\")\njwt_service = JWTService(cache_client)\n\n\nasync def get_token():\n    access, refresh = jwt_service.create_token({\"sub\": 123, \"scopes\": [\"write\"]})\n    return access, refresh\n</code></pre>"},{"location":"ko/#_4","title":"\uc2a4\ub85c\ud2c0\ub9c1","text":"<p>FastAPI/Starlette \uc5b4\ud50c\ub9ac\ucf00\uc774\uc158\uc5d0\uc11c \uc2a4\ub85c\ud2c0\ub9c1\uc744 \uc801\uc6a9\ud560 \uc218 \uc788\uc2b5\ub2c8\ub2e4.</p> <pre><code>from fastapi import FastAPI\nfrom starlette.middleware import Middleware\nfrom webtool.auth import JWTService\nfrom webtool.cache import RedisCache\nfrom webtool.throttle import limiter, LimitMiddleware, JWTBackend\n\ncache = RedisCache(\"redis://127.0.0.1:6379/0\")\njwt_backend = JWTBackend(JWTService(cache, secret_key=\"test\"))\n\napp = FastAPI(\n    middleware=[\n        Middleware(\n            LimitMiddleware,\n            cache=cache,\n            auth_backend=jwt_backend,\n        ),\n    ],\n)\n\n\n@app.get(\"/api/resource\")\n@limiter(max_requests=50, interval=3600, scopes=[\"user\"])\n@limiter(max_requests=10, interval=3600, scopes=[\"anno\"])\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"ko/#msgpack","title":"MsgPack \uc751\ub2f5","text":"<p>MessagePack-based \uc751\ub2f5.</p> <pre><code>from webtool.utils import MsgSpecJSONResponse\nfrom fastapi import FastAPI\n\napp = FastAPI(\n    default_response_class=MsgSpecJSONResponse,\n)\n\n\n@app.get(\"/api/resource\")\nasync def get_resource():\n    return {\"status\": \"success\"}\n</code></pre>"},{"location":"ko/#_5","title":"\ub77c\uc774\uc120\uc2a4","text":"<p>This project is licensed under the Apache-2.0 License.</p>"},{"location":"ko/docs/service/#usage-example_1","title":"Usage Example","text":"<pre><code>import asyncio\nfrom webtool.auth import RedisJWTService\nfrom webtool.cache import RedisCache\n\ncache = RedisCache(\"redis://localhost:6379/0\")\nredis_jwt_service = RedisJWTService(cache, secret_key=\"your_secret_key\")\n\nasync def manage_tokens():\n    user_data = {\"sub\": \"user123\"}\n    access, refresh = await redis_jwt_service.create_token(user_data)\n    print(\"Access Token:\", access)\n    print(\"Refresh Token:\", refresh)\n\n    # Validate tokens\n    access_data = await redis_jwt_service.validate_access_token(access)\n    print(\"Access Token Data:\", access_data)\n\n    refresh_data = await redis_jwt_service.validate_refresh_token(access, refresh)\n    print(\"Refresh Token Data:\", refresh_data)\n\n    # Rotate tokens\n    new_access, new_refresh = await redis_jwt_service.update_token(user_data, access, refresh)\n    print(\"New Access Token:\", new_access)\n    print(\"New Refresh Token:\", new_refresh)\n\n    # Search active tokens\n    active_tokens = await redis_jwt_service.search_token(new_access, new_refresh)\n    print(\"Active Refresh Tokens:\", active_tokens)\n\n# Example usage\nasyncio.run(manage_tokens())\n</code></pre>"}]}